/**
 * Tator REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import Affiliation from '../model/Affiliation';
import AffiliationSpec from '../model/AffiliationSpec';
import AffiliationUpdate from '../model/AffiliationUpdate';
import Algorithm from '../model/Algorithm';
import AlgorithmLaunch from '../model/AlgorithmLaunch';
import AlgorithmLaunchSpec from '../model/AlgorithmLaunchSpec';
import AlgorithmManifest from '../model/AlgorithmManifest';
import AlgorithmManifestSpec from '../model/AlgorithmManifestSpec';
import AlgorithmSpec from '../model/AlgorithmSpec';
import Analysis from '../model/Analysis';
import AnalysisSpec from '../model/AnalysisSpec';
import Announcement from '../model/Announcement';
import Applet from '../model/Applet';
import AppletSpec from '../model/AppletSpec';
import AttributeTypeDelete from '../model/AttributeTypeDelete';
import AttributeTypeSpec from '../model/AttributeTypeSpec';
import AttributeTypeUpdate from '../model/AttributeTypeUpdate';
import AttributeValue from '../model/AttributeValue';
import AudioDefinition from '../model/AudioDefinition';
import AuxiliaryFileDefinition from '../model/AuxiliaryFileDefinition';
import BadRequestResponse from '../model/BadRequestResponse';
import Bookmark from '../model/Bookmark';
import BookmarkSpec from '../model/BookmarkSpec';
import BookmarkUpdate from '../model/BookmarkUpdate';
import Bucket from '../model/Bucket';
import BucketSpec from '../model/BucketSpec';
import BucketUpdate from '../model/BucketUpdate';
import ChangeLog from '../model/ChangeLog';
import CloneMediaSpec from '../model/CloneMediaSpec';
import CreateListResponse from '../model/CreateListResponse';
import CreateResponse from '../model/CreateResponse';
import Credentials from '../model/Credentials';
import DownloadInfo from '../model/DownloadInfo';
import DownloadInfoSpec from '../model/DownloadInfoSpec';
import EmailSpec from '../model/EmailSpec';
import Favorite from '../model/Favorite';
import FavoriteSpec from '../model/FavoriteSpec';
import FavoriteUpdate from '../model/FavoriteUpdate';
import FileSpec from '../model/FileSpec';
import FileType from '../model/FileType';
import FileTypeSpec from '../model/FileTypeSpec';
import FileTypeUpdate from '../model/FileTypeUpdate';
import FileUpdate from '../model/FileUpdate';
import GenericFile from '../model/GenericFile';
import GenericFileSpec from '../model/GenericFileSpec';
import GetClonedMediaResponse from '../model/GetClonedMediaResponse';
import ImageDefinition from '../model/ImageDefinition';
import Invitation from '../model/Invitation';
import InvitationSpec from '../model/InvitationSpec';
import InvitationUpdate from '../model/InvitationUpdate';
import Job from '../model/Job';
import JobCluster from '../model/JobCluster';
import JobClusterSpec from '../model/JobClusterSpec';
import Leaf from '../model/Leaf';
import LeafBulkUpdate from '../model/LeafBulkUpdate';
import LeafIdQuery from '../model/LeafIdQuery';
import LeafSpec from '../model/LeafSpec';
import LeafSuggestion from '../model/LeafSuggestion';
import LeafType from '../model/LeafType';
import LeafTypeSpec from '../model/LeafTypeSpec';
import LeafTypeUpdate from '../model/LeafTypeUpdate';
import LeafUpdate from '../model/LeafUpdate';
import Localization from '../model/Localization';
import LocalizationBulkUpdate from '../model/LocalizationBulkUpdate';
import LocalizationIdQuery from '../model/LocalizationIdQuery';
import LocalizationSpec from '../model/LocalizationSpec';
import LocalizationType from '../model/LocalizationType';
import LocalizationTypeSpec from '../model/LocalizationTypeSpec';
import LocalizationTypeUpdate from '../model/LocalizationTypeUpdate';
import LocalizationUpdate from '../model/LocalizationUpdate';
import Media from '../model/Media';
import MediaBulkUpdate from '../model/MediaBulkUpdate';
import MediaIdQuery from '../model/MediaIdQuery';
import MediaNext from '../model/MediaNext';
import MediaPrev from '../model/MediaPrev';
import MediaSpec from '../model/MediaSpec';
import MediaStats from '../model/MediaStats';
import MediaType from '../model/MediaType';
import MediaTypeSpec from '../model/MediaTypeSpec';
import MediaTypeUpdate from '../model/MediaTypeUpdate';
import MediaUpdate from '../model/MediaUpdate';
import Membership from '../model/Membership';
import MembershipSpec from '../model/MembershipSpec';
import MembershipUpdate from '../model/MembershipUpdate';
import MessageResponse from '../model/MessageResponse';
import NotFoundResponse from '../model/NotFoundResponse';
import NotifySpec from '../model/NotifySpec';
import Organization from '../model/Organization';
import OrganizationSpec from '../model/OrganizationSpec';
import OrganizationUpdate from '../model/OrganizationUpdate';
import PasswordResetSpec from '../model/PasswordResetSpec';
import Project from '../model/Project';
import ProjectSpec from '../model/ProjectSpec';
import ProjectUpdate from '../model/ProjectUpdate';
import Section from '../model/Section';
import SectionSpec from '../model/SectionSpec';
import SectionUpdate from '../model/SectionUpdate';
import State from '../model/State';
import StateBulkUpdate from '../model/StateBulkUpdate';
import StateIdQuery from '../model/StateIdQuery';
import StateMergeUpdate from '../model/StateMergeUpdate';
import StateSpec from '../model/StateSpec';
import StateTrimUpdate from '../model/StateTrimUpdate';
import StateType from '../model/StateType';
import StateTypeSpec from '../model/StateTypeSpec';
import StateTypeUpdate from '../model/StateTypeUpdate';
import StateUpdate from '../model/StateUpdate';
import TemporaryFile from '../model/TemporaryFile';
import TemporaryFileSpec from '../model/TemporaryFileSpec';
import Token from '../model/Token';
import Transcode from '../model/Transcode';
import TranscodeSpec from '../model/TranscodeSpec';
import UploadCompletionSpec from '../model/UploadCompletionSpec';
import UploadInfo from '../model/UploadInfo';
import User from '../model/User';
import UserSpec from '../model/UserSpec';
import Version from '../model/Version';
import VersionSpec from '../model/VersionSpec';
import VersionUpdate from '../model/VersionUpdate';
import VideoClip from '../model/VideoClip';
import VideoDefinition from '../model/VideoDefinition';

/**
* Tator service.
* @module api/TatorApi
* @version 0.0.5
*/
export default class TatorApi {

    /**
    * Constructs a new TatorApi. 
    * @alias module:api/TatorApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Adds an attribute to Type.  A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeSpec} attributeTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    addAttributeWithHttpInfo(id, attributeTypeSpec) {
      let postBody = attributeTypeSpec;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling addAttribute");
      }
      // verify the required parameter 'attributeTypeSpec' is set
      if (attributeTypeSpec === undefined || attributeTypeSpec === null) {
        throw new Error("Missing the required parameter 'attributeTypeSpec' when calling addAttribute");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AttributeType/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Adds an attribute to Type.  A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeSpec} attributeTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    addAttribute(id, attributeTypeSpec) {
      return this.addAttributeWithHttpInfo(id, attributeTypeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Launch a registered algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the `Algorithms` endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the `files_per_job` field of the  `Algorithm` object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the `Job` or `JobGroup` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AlgorithmLaunchSpec} algorithmLaunchSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AlgorithmLaunch} and HTTP response
     */
    algorithmLaunchWithHttpInfo(project, algorithmLaunchSpec) {
      let postBody = algorithmLaunchSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling algorithmLaunch");
      }
      // verify the required parameter 'algorithmLaunchSpec' is set
      if (algorithmLaunchSpec === undefined || algorithmLaunchSpec === null) {
        throw new Error("Missing the required parameter 'algorithmLaunchSpec' when calling algorithmLaunch");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AlgorithmLaunch;
      return this.apiClient.callApi(
        '/rest/AlgorithmLaunch/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Launch a registered algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the `Algorithms` endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the `files_per_job` field of the  `Algorithm` object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the `Job` or `JobGroup` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AlgorithmLaunchSpec} algorithmLaunchSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AlgorithmLaunch}
     */
    algorithmLaunch(project, algorithmLaunchSpec) {
      return this.algorithmLaunchWithHttpInfo(project, algorithmLaunchSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Clone media list.  This method copies media to a different project without copying the  underlying files. It accepts the same query parameters as a `Media` `GET` request. All media matching the query will be copied to the project, media type, and section in the given request body. Section is passed as a section name; if the given section does not exist, it will be created.  This endpoint will only clone up to 500 media per request. Use the `start`, `stop`, or `after` parameters to paginate a request. 
     * @param {Number} project A unique integer identifying the source project.
     * @param {module:model/CloneMediaSpec} cloneMediaSpec 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateListResponse} and HTTP response
     */
    cloneMediaListWithHttpInfo(project, cloneMediaSpec, opts) {
      opts = opts || {};
      let postBody = cloneMediaSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling cloneMediaList");
      }
      // verify the required parameter 'cloneMediaSpec' is set
      if (cloneMediaSpec === undefined || cloneMediaSpec === null) {
        throw new Error("Missing the required parameter 'cloneMediaSpec' when calling cloneMediaList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateListResponse;
      return this.apiClient.callApi(
        '/rest/CloneMedia/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Clone media list.  This method copies media to a different project without copying the  underlying files. It accepts the same query parameters as a `Media` `GET` request. All media matching the query will be copied to the project, media type, and section in the given request body. Section is passed as a section name; if the given section does not exist, it will be created.  This endpoint will only clone up to 500 media per request. Use the `start`, `stop`, or `after` parameters to paginate a request. 
     * @param {Number} project A unique integer identifying the source project.
     * @param {module:model/CloneMediaSpec} cloneMediaSpec 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateListResponse}
     */
    cloneMediaList(project, cloneMediaSpec, opts) {
      return this.cloneMediaListWithHttpInfo(project, cloneMediaSpec, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Complete multipart upload. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/UploadCompletionSpec} uploadCompletionSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    completeUploadWithHttpInfo(project, uploadCompletionSpec) {
      let postBody = uploadCompletionSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling completeUpload");
      }
      // verify the required parameter 'uploadCompletionSpec' is set
      if (uploadCompletionSpec === undefined || uploadCompletionSpec === null) {
        throw new Error("Missing the required parameter 'uploadCompletionSpec' when calling completeUpload");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/UploadCompletion/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Complete multipart upload. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/UploadCompletionSpec} uploadCompletionSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    completeUpload(project, uploadCompletionSpec) {
      return this.completeUploadWithHttpInfo(project, uploadCompletionSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {module:model/AffiliationSpec} affiliationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createAffiliationWithHttpInfo(organization, affiliationSpec) {
      let postBody = affiliationSpec;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling createAffiliation");
      }
      // verify the required parameter 'affiliationSpec' is set
      if (affiliationSpec === undefined || affiliationSpec === null) {
        throw new Error("Missing the required parameter 'affiliationSpec' when calling createAffiliation");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Affiliations/{organization}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {module:model/AffiliationSpec} affiliationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createAffiliation(organization, affiliationSpec) {
      return this.createAffiliationWithHttpInfo(organization, affiliationSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AnalysisSpec} analysisSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createAnalysisWithHttpInfo(project, analysisSpec) {
      let postBody = analysisSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createAnalysis");
      }
      // verify the required parameter 'analysisSpec' is set
      if (analysisSpec === undefined || analysisSpec === null) {
        throw new Error("Missing the required parameter 'analysisSpec' when calling createAnalysis");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Analyses/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AnalysisSpec} analysisSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createAnalysis(project, analysisSpec) {
      return this.createAnalysisWithHttpInfo(project, analysisSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/AudioDefinition} audioDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @param {Number} opts.index Insertion index. Must be less than size of current list of audio files for the specified `role`. If omitted, the audio file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    createAudioFileWithHttpInfo(id, audioDefinition, opts) {
      opts = opts || {};
      let postBody = audioDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createAudioFile");
      }
      // verify the required parameter 'audioDefinition' is set
      if (audioDefinition === undefined || audioDefinition === null) {
        throw new Error("Missing the required parameter 'audioDefinition' when calling createAudioFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': opts['index']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AudioFiles/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/AudioDefinition} audioDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @param {Number} opts.index Insertion index. Must be less than size of current list of audio files for the specified `role`. If omitted, the audio file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    createAudioFile(id, audioDefinition, opts) {
      return this.createAudioFileWithHttpInfo(id, audioDefinition, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/AuxiliaryFileDefinition} auxiliaryFileDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @param {Number} opts.index Insertion index. Must be less than size of current list of files for the specified `role`. If omitted, the file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    createAuxiliaryFileWithHttpInfo(id, auxiliaryFileDefinition, opts) {
      opts = opts || {};
      let postBody = auxiliaryFileDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createAuxiliaryFile");
      }
      // verify the required parameter 'auxiliaryFileDefinition' is set
      if (auxiliaryFileDefinition === undefined || auxiliaryFileDefinition === null) {
        throw new Error("Missing the required parameter 'auxiliaryFileDefinition' when calling createAuxiliaryFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': opts['index']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AuxiliaryFiles/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/AuxiliaryFileDefinition} auxiliaryFileDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @param {Number} opts.index Insertion index. Must be less than size of current list of files for the specified `role`. If omitted, the file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    createAuxiliaryFile(id, auxiliaryFileDefinition, opts) {
      return this.createAuxiliaryFileWithHttpInfo(id, auxiliaryFileDefinition, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/BookmarkSpec} bookmarkSpec 
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the bookmark to filter on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createBookmarkWithHttpInfo(project, bookmarkSpec, opts) {
      opts = opts || {};
      let postBody = bookmarkSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createBookmark");
      }
      // verify the required parameter 'bookmarkSpec' is set
      if (bookmarkSpec === undefined || bookmarkSpec === null) {
        throw new Error("Missing the required parameter 'bookmarkSpec' when calling createBookmark");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'name': opts['name']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Bookmarks/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/BookmarkSpec} bookmarkSpec 
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the bookmark to filter on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createBookmark(project, bookmarkSpec, opts) {
      return this.createBookmarkWithHttpInfo(project, bookmarkSpec, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {module:model/BucketSpec} bucketSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createBucketWithHttpInfo(organization, bucketSpec) {
      let postBody = bucketSpec;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling createBucket");
      }
      // verify the required parameter 'bucketSpec' is set
      if (bucketSpec === undefined || bucketSpec === null) {
        throw new Error("Missing the required parameter 'bucketSpec' when calling createBucket");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Buckets/{organization}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {module:model/BucketSpec} bucketSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createBucket(organization, bucketSpec) {
      return this.createBucketWithHttpInfo(organization, bucketSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/FavoriteSpec} favoriteSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createFavoriteWithHttpInfo(project, favoriteSpec) {
      let postBody = favoriteSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createFavorite");
      }
      // verify the required parameter 'favoriteSpec' is set
      if (favoriteSpec === undefined || favoriteSpec === null) {
        throw new Error("Missing the required parameter 'favoriteSpec' when calling createFavorite");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Favorites/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/FavoriteSpec} favoriteSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createFavorite(project, favoriteSpec) {
      return this.createFavoriteWithHttpInfo(project, favoriteSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create generic, non-media associated File object.  Non-media assocaited files can be stored within the project along with user-defined attributes. Unlike temporary files, these are permanent. These do not include applet files and algorithm workflow files. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/FileSpec} fileSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createFileWithHttpInfo(project, fileSpec) {
      let postBody = fileSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createFile");
      }
      // verify the required parameter 'fileSpec' is set
      if (fileSpec === undefined || fileSpec === null) {
        throw new Error("Missing the required parameter 'fileSpec' when calling createFile");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Files/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create generic, non-media associated File object.  Non-media assocaited files can be stored within the project along with user-defined attributes. Unlike temporary files, these are permanent. These do not include applet files and algorithm workflow files. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/FileSpec} fileSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createFile(project, fileSpec) {
      return this.createFileWithHttpInfo(project, fileSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/FileTypeSpec} fileTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createFileTypeWithHttpInfo(project, fileTypeSpec) {
      let postBody = fileTypeSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createFileType");
      }
      // verify the required parameter 'fileTypeSpec' is set
      if (fileTypeSpec === undefined || fileTypeSpec === null) {
        throw new Error("Missing the required parameter 'fileTypeSpec' when calling createFileType");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/FileTypes/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/FileTypeSpec} fileTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createFileType(project, fileTypeSpec) {
      return this.createFileTypeWithHttpInfo(project, fileTypeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {module:model/ImageDefinition} imageDefinition 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.index Insertion index. Must be less than size of current list of images for the specified `role`. If omitted, the image file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    createImageFileWithHttpInfo(id, role, imageDefinition, opts) {
      opts = opts || {};
      let postBody = imageDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createImageFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling createImageFile");
      }
      // verify the required parameter 'imageDefinition' is set
      if (imageDefinition === undefined || imageDefinition === null) {
        throw new Error("Missing the required parameter 'imageDefinition' when calling createImageFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': opts['index']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/ImageFiles/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {module:model/ImageDefinition} imageDefinition 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.index Insertion index. Must be less than size of current list of images for the specified `role`. If omitted, the image file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    createImageFile(id, role, imageDefinition, opts) {
      return this.createImageFileWithHttpInfo(id, role, imageDefinition, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {module:model/InvitationSpec} invitationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createInvitationWithHttpInfo(organization, invitationSpec) {
      let postBody = invitationSpec;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling createInvitation");
      }
      // verify the required parameter 'invitationSpec' is set
      if (invitationSpec === undefined || invitationSpec === null) {
        throw new Error("Missing the required parameter 'invitationSpec' when calling createInvitation");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Invitations/{organization}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {module:model/InvitationSpec} invitationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createInvitation(organization, invitationSpec) {
      return this.createInvitationWithHttpInfo(organization, invitationSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     *  Create a job cluster.  This endpoint replicates the job cluster creation through the admin portal. 
     * @param {Number} id A unique integer identifying an organization.
     * @param {module:model/JobClusterSpec} jobClusterSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createJobClusterWithHttpInfo(id, jobClusterSpec) {
      let postBody = jobClusterSpec;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createJobCluster");
      }
      // verify the required parameter 'jobClusterSpec' is set
      if (jobClusterSpec === undefined || jobClusterSpec === null) {
        throw new Error("Missing the required parameter 'jobClusterSpec' when calling createJobCluster");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/JobClusters/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     *  Create a job cluster.  This endpoint replicates the job cluster creation through the admin portal. 
     * @param {Number} id A unique integer identifying an organization.
     * @param {module:model/JobClusterSpec} jobClusterSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createJobCluster(id, jobClusterSpec) {
      return this.createJobClusterWithHttpInfo(id, jobClusterSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk create on a list of `LeafSpec` objects. A  maximum of 500 leaves may be created in one request. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Array.<module:model/LeafSpec>} leafSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateListResponse} and HTTP response
     */
    createLeafListWithHttpInfo(project, leafSpec) {
      let postBody = leafSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createLeafList");
      }
      // verify the required parameter 'leafSpec' is set
      if (leafSpec === undefined || leafSpec === null) {
        throw new Error("Missing the required parameter 'leafSpec' when calling createLeafList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateListResponse;
      return this.apiClient.callApi(
        '/rest/Leaves/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk create on a list of `LeafSpec` objects. A  maximum of 500 leaves may be created in one request. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Array.<module:model/LeafSpec>} leafSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateListResponse}
     */
    createLeafList(project, leafSpec) {
      return this.createLeafListWithHttpInfo(project, leafSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafTypeSpec} leafTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createLeafTypeWithHttpInfo(project, leafTypeSpec) {
      let postBody = leafTypeSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createLeafType");
      }
      // verify the required parameter 'leafTypeSpec' is set
      if (leafTypeSpec === undefined || leafTypeSpec === null) {
        throw new Error("Missing the required parameter 'leafTypeSpec' when calling createLeafType");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/LeafTypes/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafTypeSpec} leafTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createLeafType(project, leafTypeSpec) {
      return this.createLeafTypeWithHttpInfo(project, leafTypeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `LocalizationSpec` objects. A  maximum of 500 localizations may be created in one request. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Array.<module:model/LocalizationSpec>} localizationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateListResponse} and HTTP response
     */
    createLocalizationListWithHttpInfo(project, localizationSpec) {
      let postBody = localizationSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createLocalizationList");
      }
      // verify the required parameter 'localizationSpec' is set
      if (localizationSpec === undefined || localizationSpec === null) {
        throw new Error("Missing the required parameter 'localizationSpec' when calling createLocalizationList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateListResponse;
      return this.apiClient.callApi(
        '/rest/Localizations/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `LocalizationSpec` objects. A  maximum of 500 localizations may be created in one request. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Array.<module:model/LocalizationSpec>} localizationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateListResponse}
     */
    createLocalizationList(project, localizationSpec) {
      return this.createLocalizationListWithHttpInfo(project, localizationSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationTypeSpec} localizationTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createLocalizationTypeWithHttpInfo(project, localizationTypeSpec) {
      let postBody = localizationTypeSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createLocalizationType");
      }
      // verify the required parameter 'localizationTypeSpec' is set
      if (localizationTypeSpec === undefined || localizationTypeSpec === null) {
        throw new Error("Missing the required parameter 'localizationTypeSpec' when calling createLocalizationType");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/LocalizationTypes/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationTypeSpec} localizationTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createLocalizationType(project, localizationTypeSpec) {
      return this.createLocalizationTypeWithHttpInfo(project, localizationTypeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method creates a `Media` object in the database. For images, the  media must already be uploaded and an upload URL must be provided, as well as the group and job IDs associated with the upload. For videos, it is recommended to use the `Transcode` endpoint, which will create the media object itself. This method is only needed for local  transcodes. In that case, it will create an empty Media object; thumbnails, streaming, and archival videos must be subsequently uploaded  and saved via the `Media` PATCH method. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaSpec} mediaSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createMediaWithHttpInfo(project, mediaSpec) {
      let postBody = mediaSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createMedia");
      }
      // verify the required parameter 'mediaSpec' is set
      if (mediaSpec === undefined || mediaSpec === null) {
        throw new Error("Missing the required parameter 'mediaSpec' when calling createMedia");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Medias/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method creates a `Media` object in the database. For images, the  media must already be uploaded and an upload URL must be provided, as well as the group and job IDs associated with the upload. For videos, it is recommended to use the `Transcode` endpoint, which will create the media object itself. This method is only needed for local  transcodes. In that case, it will create an empty Media object; thumbnails, streaming, and archival videos must be subsequently uploaded  and saved via the `Media` PATCH method. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaSpec} mediaSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createMedia(project, mediaSpec) {
      return this.createMediaWithHttpInfo(project, mediaSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaTypeSpec} mediaTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createMediaTypeWithHttpInfo(project, mediaTypeSpec) {
      let postBody = mediaTypeSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createMediaType");
      }
      // verify the required parameter 'mediaTypeSpec' is set
      if (mediaTypeSpec === undefined || mediaTypeSpec === null) {
        throw new Error("Missing the required parameter 'mediaTypeSpec' when calling createMediaType");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/MediaTypes/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaTypeSpec} mediaTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createMediaType(project, mediaTypeSpec) {
      return this.createMediaTypeWithHttpInfo(project, mediaTypeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MembershipSpec} membershipSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createMembershipWithHttpInfo(project, membershipSpec) {
      let postBody = membershipSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createMembership");
      }
      // verify the required parameter 'membershipSpec' is set
      if (membershipSpec === undefined || membershipSpec === null) {
        throw new Error("Missing the required parameter 'membershipSpec' when calling createMembership");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Memberships/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MembershipSpec} membershipSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createMembership(project, membershipSpec) {
      return this.createMembershipWithHttpInfo(project, membershipSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get API token.  This method accepts login credentials and returns an API token that can be used with the Tator REST API, tator-py, or tator-r.  
     * @param {module:model/Credentials} credentials 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Token} and HTTP response
     */
    createObtainAuthTokenWithHttpInfo(credentials) {
      let postBody = credentials;
      // verify the required parameter 'credentials' is set
      if (credentials === undefined || credentials === null) {
        throw new Error("Missing the required parameter 'credentials' when calling createObtainAuthToken");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Token;
      return this.apiClient.callApi(
        '/rest/Token', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get API token.  This method accepts login credentials and returns an API token that can be used with the Tator REST API, tator-py, or tator-r.  
     * @param {module:model/Credentials} credentials 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Token}
     */
    createObtainAuthToken(credentials) {
      return this.createObtainAuthTokenWithHttpInfo(credentials)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   
     * @param {module:model/OrganizationSpec} organizationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createOrganizationWithHttpInfo(organizationSpec) {
      let postBody = organizationSpec;
      // verify the required parameter 'organizationSpec' is set
      if (organizationSpec === undefined || organizationSpec === null) {
        throw new Error("Missing the required parameter 'organizationSpec' when calling createOrganization");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Organizations', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   
     * @param {module:model/OrganizationSpec} organizationSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createOrganization(organizationSpec) {
      return this.createOrganizationWithHttpInfo(organizationSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create password reset.  This endpoint will send an email to a registered user with the email address provided. The email will contain a link that will allow the user to reset their password. If the email address is registered for multiple users or no users an exception will be raised and an email will not be sent. If the email fails to be sent, either due to a bad response or system configuration that does not allow sending emails, an exception will be raised. 
     * @param {module:model/PasswordResetSpec} passwordResetSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    createPasswordResetWithHttpInfo(passwordResetSpec) {
      let postBody = passwordResetSpec;
      // verify the required parameter 'passwordResetSpec' is set
      if (passwordResetSpec === undefined || passwordResetSpec === null) {
        throw new Error("Missing the required parameter 'passwordResetSpec' when calling createPasswordReset");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/PasswordReset', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create password reset.  This endpoint will send an email to a registered user with the email address provided. The email will contain a link that will allow the user to reset their password. If the email address is registered for multiple users or no users an exception will be raised and an email will not be sent. If the email fails to be sent, either due to a bad response or system configuration that does not allow sending emails, an exception will be raised. 
     * @param {module:model/PasswordResetSpec} passwordResetSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    createPasswordReset(passwordResetSpec) {
      return this.createPasswordResetWithHttpInfo(passwordResetSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
     * @param {module:model/ProjectSpec} projectSpec 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.organization Unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createProjectWithHttpInfo(projectSpec, opts) {
      opts = opts || {};
      let postBody = projectSpec;
      // verify the required parameter 'projectSpec' is set
      if (projectSpec === undefined || projectSpec === null) {
        throw new Error("Missing the required parameter 'projectSpec' when calling createProject");
      }

      let pathParams = {
      };
      let queryParams = {
        'organization': opts['organization']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Projects', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
     * @param {module:model/ProjectSpec} projectSpec 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.organization Unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createProject(projectSpec, opts) {
      return this.createProjectWithHttpInfo(projectSpec, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media.   Note: In order for a section to be interpreted properly, the tator_user_sections attribute of the SectionSpec cannot be None. The front end assigns a uuid1 string for this attribute, but it is not required to follow this pattern.
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/SectionSpec} sectionSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createSectionWithHttpInfo(project, sectionSpec) {
      let postBody = sectionSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createSection");
      }
      // verify the required parameter 'sectionSpec' is set
      if (sectionSpec === undefined || sectionSpec === null) {
        throw new Error("Missing the required parameter 'sectionSpec' when calling createSection");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Sections/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media.   Note: In order for a section to be interpreted properly, the tator_user_sections attribute of the SectionSpec cannot be None. The front end assigns a uuid1 string for this attribute, but it is not required to follow this pattern.
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/SectionSpec} sectionSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createSection(project, sectionSpec) {
      return this.createSectionWithHttpInfo(project, sectionSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `StateSpec` objects. A  maximum of 500 states may be created in one request. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Array.<module:model/StateSpec>} stateSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateListResponse} and HTTP response
     */
    createStateListWithHttpInfo(project, stateSpec) {
      let postBody = stateSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createStateList");
      }
      // verify the required parameter 'stateSpec' is set
      if (stateSpec === undefined || stateSpec === null) {
        throw new Error("Missing the required parameter 'stateSpec' when calling createStateList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateListResponse;
      return this.apiClient.callApi(
        '/rest/States/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk create on a list of `StateSpec` objects. A  maximum of 500 states may be created in one request. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Array.<module:model/StateSpec>} stateSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateListResponse}
     */
    createStateList(project, stateSpec) {
      return this.createStateListWithHttpInfo(project, stateSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateTypeSpec} stateTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createStateTypeWithHttpInfo(project, stateTypeSpec) {
      let postBody = stateTypeSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createStateType");
      }
      // verify the required parameter 'stateTypeSpec' is set
      if (stateTypeSpec === undefined || stateTypeSpec === null) {
        throw new Error("Missing the required parameter 'stateTypeSpec' when calling createStateType");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/StateTypes/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateTypeSpec} stateTypeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createStateType(project, stateTypeSpec) {
      return this.createStateTypeWithHttpInfo(project, stateTypeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create temporary file.  Temporary files are files stored server side for a defined duration.   The file must first be uploaded via tus, and can subsequently be saved using this endpoint.
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/TemporaryFileSpec} temporaryFileSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createTemporaryFileWithHttpInfo(project, temporaryFileSpec) {
      let postBody = temporaryFileSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createTemporaryFile");
      }
      // verify the required parameter 'temporaryFileSpec' is set
      if (temporaryFileSpec === undefined || temporaryFileSpec === null) {
        throw new Error("Missing the required parameter 'temporaryFileSpec' when calling createTemporaryFile");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/TemporaryFiles/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create temporary file.  Temporary files are files stored server side for a defined duration.   The file must first be uploaded via tus, and can subsequently be saved using this endpoint.
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/TemporaryFileSpec} temporaryFileSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createTemporaryFile(project, temporaryFileSpec) {
      return this.createTemporaryFileWithHttpInfo(project, temporaryFileSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create user.  This method accepts a registration token that is provided by creating a Invitation object. It is optional if anonymous registration is enabled, but otherwise required. If anonymous registration is enabled and email confirmation is also enabled, the method will create an inactive user with a confirmation token. The user can be activated by visiting a link that is automatically sent to the user. If anonymous registration without confirmation is enabled, any user can be created with this method. 
     * @param {module:model/UserSpec} userSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    createUserWithHttpInfo(userSpec) {
      let postBody = userSpec;
      // verify the required parameter 'userSpec' is set
      if (userSpec === undefined || userSpec === null) {
        throw new Error("Missing the required parameter 'userSpec' when calling createUser");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Users', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create user.  This method accepts a registration token that is provided by creating a Invitation object. It is optional if anonymous registration is enabled, but otherwise required. If anonymous registration is enabled and email confirmation is also enabled, the method will create an inactive user with a confirmation token. The user can be activated by visiting a link that is automatically sent to the user. If anonymous registration without confirmation is enabled, any user can be created with this method. 
     * @param {module:model/UserSpec} userSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    createUser(userSpec) {
      return this.createUserWithHttpInfo(userSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/VersionSpec} versionSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    createVersionWithHttpInfo(project, versionSpec) {
      let postBody = versionSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling createVersion");
      }
      // verify the required parameter 'versionSpec' is set
      if (versionSpec === undefined || versionSpec === null) {
        throw new Error("Missing the required parameter 'versionSpec' when calling createVersion");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Versions/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/VersionSpec} versionSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    createVersion(project, versionSpec) {
      return this.createVersionWithHttpInfo(project, versionSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {module:model/VideoDefinition} videoDefinition 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.index Insertion index. Must be less than size of current list of videos for the specified `role`. If omitted, the video file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    createVideoFileWithHttpInfo(id, role, videoDefinition, opts) {
      opts = opts || {};
      let postBody = videoDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling createVideoFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling createVideoFile");
      }
      // verify the required parameter 'videoDefinition' is set
      if (videoDefinition === undefined || videoDefinition === null) {
        throw new Error("Missing the required parameter 'videoDefinition' when calling createVideoFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': opts['index']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/VideoFiles/{id}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {module:model/VideoDefinition} videoDefinition 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.index Insertion index. Must be less than size of current list of videos for the specified `role`. If omitted, the video file will be appended to the end of the list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    createVideoFile(id, role, videoDefinition, opts) {
      return this.createVideoFileWithHttpInfo(id, role, videoDefinition, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} id A unique integer identifying a affiliation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAffiliationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAffiliation");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Affiliation/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} id A unique integer identifying a affiliation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAffiliation(id) {
      return this.deleteAffiliationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete registered algorithm workflow
     * @param {Number} id A unique integer identifying a registered algorithm workflow.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAlgorithmWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAlgorithm");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Algorithm/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete registered algorithm workflow
     * @param {Number} id A unique integer identifying a registered algorithm workflow.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAlgorithm(id) {
      return this.deleteAlgorithmWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete analysis record
     * @param {Number} id A unique integer identifying an analysis record.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAnalysisWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAnalysis");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Analysis/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete analysis record
     * @param {Number} id A unique integer identifying an analysis record.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAnalysis(id) {
      return this.deleteAnalysisWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete announcement.  Announcements are system-wide messages sent to users. Users may delete individual announcements to acknowledge and stop displaying them. 
     * @param {Number} id A unique integer identifying a announcement.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAnnouncementWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAnnouncement");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Announcement/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete announcement.  Announcements are system-wide messages sent to users. Users may delete individual announcements to acknowledge and stop displaying them. 
     * @param {Number} id A unique integer identifying a announcement.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAnnouncement(id) {
      return this.deleteAnnouncementWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete registered applet file
     * @param {Number} id A unique integer identifying a registered applet file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAppletWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteApplet");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Applet/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete registered applet file
     * @param {Number} id A unique integer identifying a registered applet file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteApplet(id) {
      return this.deleteAppletWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Deletes an existing attribute on Type.  A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeDelete} attributeTypeDelete 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAttributeWithHttpInfo(id, attributeTypeDelete) {
      let postBody = attributeTypeDelete;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAttribute");
      }
      // verify the required parameter 'attributeTypeDelete' is set
      if (attributeTypeDelete === undefined || attributeTypeDelete === null) {
        throw new Error("Missing the required parameter 'attributeTypeDelete' when calling deleteAttribute");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AttributeType/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Deletes an existing attribute on Type.  A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeDelete} attributeTypeDelete 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAttribute(id, attributeTypeDelete) {
      return this.deleteAttributeWithHttpInfo(id, attributeTypeDelete)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of audio files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAudioFileWithHttpInfo(id, index, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAudioFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling deleteAudioFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AudioFile/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of audio files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAudioFile(id, index, opts) {
      return this.deleteAudioFileWithHttpInfo(id, index, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete auxiliary file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteAuxiliaryFileWithHttpInfo(id, index, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteAuxiliaryFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling deleteAuxiliaryFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AuxiliaryFile/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete auxiliary file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteAuxiliaryFile(id, index, opts) {
      return this.deleteAuxiliaryFileWithHttpInfo(id, index, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} id A unique integer identifying a bookmark.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteBookmarkWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteBookmark");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Bookmark/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} id A unique integer identifying a bookmark.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteBookmark(id) {
      return this.deleteBookmarkWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} id A unique integer identifying a bucket.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteBucketWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteBucket");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Bucket/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} id A unique integer identifying a bucket.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteBucket(id) {
      return this.deleteBucketWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} id A unique integer identifying a favorite.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteFavoriteWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFavorite");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Favorite/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} id A unique integer identifying a favorite.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteFavorite(id) {
      return this.deleteFavoriteWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete registered non-media File object
     * @param {Number} id A unique integer identifying a registered File object.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteFileWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/File/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete registered non-media File object
     * @param {Number} id A unique integer identifying a registered File object.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteFile(id) {
      return this.deleteFileWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes.   Note that this will also delete any files associated with the file type. 
     * @param {Number} id A unique integer identifying an file type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteFileTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteFileType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/FileType/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes.   Note that this will also delete any files associated with the file type. 
     * @param {Number} id A unique integer identifying an file type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteFileType(id) {
      return this.deleteFileTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of images for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteImageFileWithHttpInfo(id, role, index) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteImageFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling deleteImageFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling deleteImageFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/ImageFile/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of images for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteImageFile(id, role, index) {
      return this.deleteImageFileWithHttpInfo(id, role, index)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} id A unique integer identifying a invitation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteInvitationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteInvitation");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Invitation/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} id A unique integer identifying a invitation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteInvitation(id) {
      return this.deleteInvitationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to cancel a job using the `uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {String} uid A uuid1 string identifying to single Job.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteJobWithHttpInfo(uid) {
      let postBody = null;
      // verify the required parameter 'uid' is set
      if (uid === undefined || uid === null) {
        throw new Error("Missing the required parameter 'uid' when calling deleteJob");
      }

      let pathParams = {
        'uid': uid
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Job/{uid}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to cancel a job using the `uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {String} uid A uuid1 string identifying to single Job.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteJob(uid) {
      return this.deleteJobWithHttpInfo(uid)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete registered job cluster
     * @param {Number} id A unique integer identifying a registered job cluster.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteJobClusterWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteJobCluster");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/JobCluster/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete registered job cluster
     * @param {Number} id A unique integer identifying a registered job cluster.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteJobCluster(id) {
      return this.deleteJobClusterWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete background job list.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to batch delete a list of jobs that were created by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.gid A UUID string identifying a group of jobs.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteJobListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling deleteJobList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'gid': opts['gid']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Jobs/{project}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete background job list.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to batch delete a list of jobs that were created by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.gid A UUID string identifying a group of jobs.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteJobList(project, opts) {
      return this.deleteJobListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
     * @param {Number} id A unique integer identifying a leaf.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteLeafWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteLeaf");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Leaf/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
     * @param {Number} id A unique integer identifying a leaf.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteLeaf(id) {
      return this.deleteLeafWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method performs a bulk delete on all leaves matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {module:model/LeafIdQuery} opts.leafIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteLeafListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = opts['leafIdQuery'];
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling deleteLeafList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'type': opts['type'],
        'name': opts['name'],
        'depth': opts['depth'],
        'leaf_id': this.apiClient.buildCollectionParam(opts['leafId'], 'multi'),
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Leaves/{project}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method performs a bulk delete on all leaves matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {module:model/LeafIdQuery} opts.leafIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteLeafList(project, opts) {
      return this.deleteLeafListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} id A unique integer identifying an leaf type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteLeafTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteLeafType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/LeafType/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} id A unique integer identifying an leaf type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteLeafType(id) {
      return this.deleteLeafTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a localization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteLocalizationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteLocalization");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Localization/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a localization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteLocalization(id) {
      return this.deleteLocalizationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all localizations matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @param {module:model/LocalizationIdQuery} opts.localizationIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteLocalizationListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = opts['localizationIdQuery'];
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling deleteLocalizationList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs'],
        'excludeParents': opts['excludeParents'],
        'frame': opts['frame']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Localizations/{project}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all localizations matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @param {module:model/LocalizationIdQuery} opts.localizationIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteLocalizationList(project, opts) {
      return this.deleteLocalizationListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any localizations associated with the localization type. 
     * @param {Number} id A unique integer identifying a localization type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteLocalizationTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteLocalizationType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/LocalizationType/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any localizations associated with the localization type. 
     * @param {Number} id A unique integer identifying a localization type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteLocalizationType(id) {
      return this.deleteLocalizationTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} id A unique integer identifying a media.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteMediaWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteMedia");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Media/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} id A unique integer identifying a media.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteMedia(id) {
      return this.deleteMediaWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all media matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {module:model/MediaIdQuery} opts.mediaIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteMediaListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = opts['mediaIdQuery'];
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling deleteMediaList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Medias/{project}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all media matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {module:model/MediaIdQuery} opts.mediaIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteMediaList(project, opts) {
      return this.deleteMediaListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   Note that this will also delete any media associated with the media type. 
     * @param {Number} id A unique integer identifying an media type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteMediaTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteMediaType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/MediaType/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   Note that this will also delete any media associated with the media type. 
     * @param {Number} id A unique integer identifying an media type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteMediaType(id) {
      return this.deleteMediaTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} id A unique integer identifying a membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteMembershipWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteMembership");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Membership/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} id A unique integer identifying a membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteMembership(id) {
      return this.deleteMembershipWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   Only organization owners may delete an organization. 
     * @param {Number} id A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteOrganizationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteOrganization");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Organization/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   Only organization owners may delete an organization. 
     * @param {Number} id A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteOrganization(id) {
      return this.deleteOrganizationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Only project owners may delete a project. Note that deleting a project will also delete all media and annotations within a project. 
     * @param {Number} id A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteProjectWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteProject");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Project/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Only project owners may delete a project. Note that deleting a project will also delete all media and annotations within a project. 
     * @param {Number} id A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteProject(id) {
      return this.deleteProjectWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media. 
     * @param {Number} id A unique integer identifying a section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteSectionWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteSection");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Section/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media. 
     * @param {Number} id A unique integer identifying a section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteSection(id) {
      return this.deleteSectionWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a state.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteStateWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteState");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/State/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a state.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteState(id) {
      return this.deleteStateWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all states matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {module:model/StateIdQuery} opts.stateIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteStateListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = opts['stateIdQuery'];
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling deleteStateList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/States/{project}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method performs a bulk delete on all states matching a query. It is  recommended to use a GET request first to check what is being deleted. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {module:model/StateIdQuery} opts.stateIdQuery 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteStateList(project, opts) {
      return this.deleteStateListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any states associated with the state type. 
     * @param {Number} id A unique integer identifying a state type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteStateTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteStateType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/StateType/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   Note that this will also delete any states associated with the state type. 
     * @param {Number} id A unique integer identifying a state type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteStateType(id) {
      return this.deleteStateTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete temporary file.  Temporary files are files stored server side for a defined duration. 
     * @param {Number} id A unique integer identifying a temporary file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteTemporaryFileWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteTemporaryFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/TemporaryFile/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete temporary file.  Temporary files are files stored server side for a defined duration. 
     * @param {Number} id A unique integer identifying a temporary file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteTemporaryFile(id) {
      return this.deleteTemporaryFileWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete temporary file list.  Temporary files are files stored server side for a defined duration.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expired If greater than 0 will return only expired files (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteTemporaryFileListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling deleteTemporaryFileList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'expired': opts['expired']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/TemporaryFiles/{project}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete temporary file list.  Temporary files are files stored server side for a defined duration.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expired If greater than 0 will return only expired files (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteTemporaryFileList(project, opts) {
      return this.deleteTemporaryFileListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.   Note that this will also delete any localizations or states associated with the deleted version. 
     * @param {Number} id A unique integer identifying a version.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteVersionWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteVersion");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Version/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.   Note that this will also delete any localizations or states associated with the deleted version. 
     * @param {Number} id A unique integer identifying a version.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteVersion(id) {
      return this.deleteVersionWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of videos for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    deleteVideoFileWithHttpInfo(id, role, index) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteVideoFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling deleteVideoFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling deleteVideoFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/VideoFile/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of videos for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    deleteVideoFile(id, role, index) {
      return this.deleteVideoFileWithHttpInfo(id, role, index)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} id A unique integer identifying a affiliation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Affiliation} and HTTP response
     */
    getAffiliationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAffiliation");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Affiliation;
      return this.apiClient.callApi(
        '/rest/Affiliation/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} id A unique integer identifying a affiliation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Affiliation}
     */
    getAffiliation(id) {
      return this.getAffiliationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get affiliation list.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} organization A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Affiliation>} and HTTP response
     */
    getAffiliationListWithHttpInfo(organization) {
      let postBody = null;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling getAffiliationList");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Affiliation];
      return this.apiClient.callApi(
        '/rest/Affiliations/{organization}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get affiliation list.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} organization A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Affiliation>}
     */
    getAffiliationList(organization) {
      return this.getAffiliationListWithHttpInfo(organization)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get registered algorithm workflow
     * @param {Number} id A unique integer identifying a registered algorithm workflow.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Algorithm} and HTTP response
     */
    getAlgorithmWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAlgorithm");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Algorithm;
      return this.apiClient.callApi(
        '/rest/Algorithm/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get registered algorithm workflow
     * @param {Number} id A unique integer identifying a registered algorithm workflow.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Algorithm}
     */
    getAlgorithm(id) {
      return this.getAlgorithmWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get registered algorithms. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Algorithm>} and HTTP response
     */
    getAlgorithmListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getAlgorithmList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Algorithm];
      return this.apiClient.callApi(
        '/rest/Algorithms/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get registered algorithms. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Algorithm>}
     */
    getAlgorithmList(project) {
      return this.getAlgorithmListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get analysis record
     * @param {Number} id A unique integer identifying an analysis record.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Analysis} and HTTP response
     */
    getAnalysisWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAnalysis");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Analysis;
      return this.apiClient.callApi(
        '/rest/Analysis/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get analysis record
     * @param {Number} id A unique integer identifying an analysis record.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Analysis}
     */
    getAnalysis(id) {
      return this.getAnalysisWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Analysis>} and HTTP response
     */
    getAnalysisListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getAnalysisList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Analysis];
      return this.apiClient.callApi(
        '/rest/Analyses/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get analysis.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Analysis>}
     */
    getAnalysisList(project) {
      return this.getAnalysisListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get announcement list.  Announcements are system-wide messages sent to users. Users may delete individual announcements to acknowledge and stop displaying them. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Announcement>} and HTTP response
     */
    getAnnouncementListWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Announcement];
      return this.apiClient.callApi(
        '/rest/Announcements', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get announcement list.  Announcements are system-wide messages sent to users. Users may delete individual announcements to acknowledge and stop displaying them. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Announcement>}
     */
    getAnnouncementList() {
      return this.getAnnouncementListWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Allows for logging into Tator as an anonymous user. 
     * @param {Object} opts Optional parameters
     * @param {String} opts.redirect URI to redirect to after logging in as anonymous user. Defaults to /projects.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<Object>} and HTTP response
     */
    getAnonymousGatewaySchemaWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'redirect': opts['redirect']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/plain'];
      let returnType = [Object];
      return this.apiClient.callApi(
        '/anonymous-gateway', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Allows for logging into Tator as an anonymous user. 
     * @param {Object} opts Optional parameters
     * @param {String} opts.redirect URI to redirect to after logging in as anonymous user. Defaults to /projects.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<Object>}
     */
    getAnonymousGatewaySchema(opts) {
      return this.getAnonymousGatewaySchemaWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get registered applet file
     * @param {Number} id A unique integer identifying a registered applet file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Applet} and HTTP response
     */
    getAppletWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getApplet");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Applet;
      return this.apiClient.callApi(
        '/rest/Applet/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get registered applet file
     * @param {Number} id A unique integer identifying a registered applet file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Applet}
     */
    getApplet(id) {
      return this.getAppletWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get applet list.  Applets are customized interfaces (i.e. html files) displayed within the Tator projects. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Applet>} and HTTP response
     */
    getAppletListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getAppletList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Applet];
      return this.apiClient.callApi(
        '/rest/Applets/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get applet list.  Applets are customized interfaces (i.e. html files) displayed within the Tator projects. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Applet>}
     */
    getAppletList(project) {
      return this.getAppletListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of audio files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AudioDefinition} and HTTP response
     */
    getAudioFileWithHttpInfo(id, index, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAudioFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling getAudioFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = AudioDefinition;
      return this.apiClient.callApi(
        '/rest/AudioFile/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of audio files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AudioDefinition}
     */
    getAudioFile(id, index, opts) {
      return this.getAudioFileWithHttpInfo(id, index, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get audio file list.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/AudioDefinition>} and HTTP response
     */
    getAudioFileListWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAudioFileList");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [AudioDefinition];
      return this.apiClient.callApi(
        '/rest/AudioFiles/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get audio file list.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/AudioDefinition>}
     */
    getAudioFileList(id, opts) {
      return this.getAudioFileListWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get auxiliary file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AuxiliaryFileDefinition} and HTTP response
     */
    getAuxiliaryFileWithHttpInfo(id, index, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAuxiliaryFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling getAuxiliaryFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = AuxiliaryFileDefinition;
      return this.apiClient.callApi(
        '/rest/AuxiliaryFile/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get auxiliary file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of files for the specified `role`.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AuxiliaryFileDefinition}
     */
    getAuxiliaryFile(id, index, opts) {
      return this.getAuxiliaryFileWithHttpInfo(id, index, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get file list.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/AuxiliaryFileDefinition>} and HTTP response
     */
    getAuxiliaryFileListWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAuxiliaryFileList");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [AuxiliaryFileDefinition];
      return this.apiClient.callApi(
        '/rest/AuxiliaryFiles/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get file list.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/AuxiliaryFileDefinition>}
     */
    getAuxiliaryFileList(id, opts) {
      return this.getAuxiliaryFileListWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} id A unique integer identifying a bookmark.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Bookmark} and HTTP response
     */
    getBookmarkWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getBookmark");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Bookmark;
      return this.apiClient.callApi(
        '/rest/Bookmark/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} id A unique integer identifying a bookmark.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Bookmark}
     */
    getBookmark(id) {
      return this.getBookmarkWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get bookmark list.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the bookmark to filter on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Bookmark>} and HTTP response
     */
    getBookmarkListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getBookmarkList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'name': opts['name']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Bookmark];
      return this.apiClient.callApi(
        '/rest/Bookmarks/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get bookmark list.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the bookmark to filter on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Bookmark>}
     */
    getBookmarkList(project, opts) {
      return this.getBookmarkListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} id A unique integer identifying a bucket.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Bucket} and HTTP response
     */
    getBucketWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getBucket");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Bucket;
      return this.apiClient.callApi(
        '/rest/Bucket/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} id A unique integer identifying a bucket.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Bucket}
     */
    getBucket(id) {
      return this.getBucketWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get bucket list.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} organization A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Bucket>} and HTTP response
     */
    getBucketListWithHttpInfo(organization) {
      let postBody = null;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling getBucketList");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Bucket];
      return this.apiClient.callApi(
        '/rest/Buckets/{organization}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get bucket list.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} organization A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Bucket>}
     */
    getBucketList(organization) {
      return this.getBucketListWithHttpInfo(organization)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a list of change logs.   A ChangeLog is the object containing information about a change applied to an object. It includes the time, user, and description of the change. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.userId Filters ChangeLogs for the given user.
     * @param {Number} opts.entityId Filters ChangeLogs for the given entity.
     * @param {module:model/String} opts.entityType Filters ChangeLogs for the given entity type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/ChangeLog>} and HTTP response
     */
    getChangeLogListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getChangeLogList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'user_id': opts['userId'],
        'entity_id': opts['entityId'],
        'entity_type': opts['entityType']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ChangeLog];
      return this.apiClient.callApi(
        '/rest/ChangeLog/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a list of change logs.   A ChangeLog is the object containing information about a change applied to an object. It includes the time, user, and description of the change. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.userId Filters ChangeLogs for the given user.
     * @param {Number} opts.entityId Filters ChangeLogs for the given entity.
     * @param {module:model/String} opts.entityType Filters ChangeLogs for the given entity type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/ChangeLog>}
     */
    getChangeLogList(project, opts) {
      return this.getChangeLogListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get video clip.  Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Array.<String>} frameRanges Comma-seperated list of frame ranges to capture.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.quality Source resolution to use (default to highest quality)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/VideoClip} and HTTP response
     */
    getClipWithHttpInfo(id, frameRanges, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getClip");
      }
      // verify the required parameter 'frameRanges' is set
      if (frameRanges === undefined || frameRanges === null) {
        throw new Error("Missing the required parameter 'frameRanges' when calling getClip");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'frameRanges': this.apiClient.buildCollectionParam(frameRanges, 'csv'),
        'quality': opts['quality']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = VideoClip;
      return this.apiClient.callApi(
        '/rest/GetClip/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get video clip.  Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Array.<String>} frameRanges Comma-seperated list of frame ranges to capture.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.quality Source resolution to use (default to highest quality)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/VideoClip}
     */
    getClip(id, frameRanges, opts) {
      return this.getClipWithHttpInfo(id, frameRanges, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     *  Get cloned media.  This method finds and returns the list of media ids that are clones of the given id. 
     * @param {Number} id A unique integer identifying a media object.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetClonedMediaResponse} and HTTP response
     */
    getClonedMediaWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getClonedMedia");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GetClonedMediaResponse;
      return this.apiClient.callApi(
        '/rest/GetClonedMedia/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     *  Get cloned media.  This method finds and returns the list of media ids that are clones of the given id. 
     * @param {Number} id A unique integer identifying a media object.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetClonedMediaResponse}
     */
    getClonedMedia(id) {
      return this.getClonedMediaWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve URL for one or more file downloads from a given project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/DownloadInfoSpec} downloadInfoSpec 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expiration Number of seconds until URL expires and becomes invalid. (default to 86400)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/DownloadInfo>} and HTTP response
     */
    getDownloadInfoWithHttpInfo(project, downloadInfoSpec, opts) {
      opts = opts || {};
      let postBody = downloadInfoSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getDownloadInfo");
      }
      // verify the required parameter 'downloadInfoSpec' is set
      if (downloadInfoSpec === undefined || downloadInfoSpec === null) {
        throw new Error("Missing the required parameter 'downloadInfoSpec' when calling getDownloadInfo");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'expiration': opts['expiration']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [DownloadInfo];
      return this.apiClient.callApi(
        '/rest/DownloadInfo/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve URL for one or more file downloads from a given project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/DownloadInfoSpec} downloadInfoSpec 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expiration Number of seconds until URL expires and becomes invalid. (default to 86400)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/DownloadInfo>}
     */
    getDownloadInfo(project, downloadInfoSpec, opts) {
      return this.getDownloadInfoWithHttpInfo(project, downloadInfoSpec, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} id A unique integer identifying a favorite.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Favorite} and HTTP response
     */
    getFavoriteWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFavorite");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Favorite;
      return this.apiClient.callApi(
        '/rest/Favorite/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} id A unique integer identifying a favorite.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Favorite}
     */
    getFavorite(id) {
      return this.getFavoriteWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get favorite list.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Favorite>} and HTTP response
     */
    getFavoriteListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getFavoriteList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Favorite];
      return this.apiClient.callApi(
        '/rest/Favorites/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get favorite list.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Favorite>}
     */
    getFavoriteList(project) {
      return this.getFavoriteListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get registered non-media File object
     * @param {Number} id A unique integer identifying a registered File object.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    getFileWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/rest/File/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get registered non-media File object
     * @param {Number} id A unique integer identifying a registered File object.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    getFile(id) {
      return this.getFileWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get non-media associated File object list.  Non-media assocaited files can be stored within the project along with user-defined attributes. Unlike temporary files, these are permanent. These do not include applet files and algorithm workflow files. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.meta Unique integer identifying a FileType.
     * @param {Number} opts.after If given, all results returned will be after the File object with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<File>} and HTTP response
     */
    getFileListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getFileList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'meta': opts['meta'],
        'after': opts['after'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [File];
      return this.apiClient.callApi(
        '/rest/Files/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get non-media associated File object list.  Non-media assocaited files can be stored within the project along with user-defined attributes. Unlike temporary files, these are permanent. These do not include applet files and algorithm workflow files. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.meta Unique integer identifying a FileType.
     * @param {Number} opts.after If given, all results returned will be after the File object with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<File>}
     */
    getFileList(project, opts) {
      return this.getFileListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes.   
     * @param {Number} id A unique integer identifying an file type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/FileType} and HTTP response
     */
    getFileTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFileType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = FileType;
      return this.apiClient.callApi(
        '/rest/FileType/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes.   
     * @param {Number} id A unique integer identifying an file type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/FileType}
     */
    getFileType(id) {
      return this.getFileTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get file type list.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/FileType>} and HTTP response
     */
    getFileTypeListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getFileTypeList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [FileType];
      return this.apiClient.callApi(
        '/rest/FileTypes/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get file type list.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/FileType>}
     */
    getFileTypeList(project) {
      return this.getFileTypeListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get frame(s) from a video.  Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.frames Comma-seperated list of frames to capture.
     * @param {String} opts.tile wxh, if not supplied is made as squarish as possible.
     * @param {String} opts.roi w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
     * @param {String} opts.forceScale Size of each frame image to return in format wxh. This forces scaling the image. Applied after ROI crop if any.Default is the size of the frame for highest streaming resolution. Example: 1024x768
     * @param {Number} opts.animate If not tiling, animate each frame at a given fps in a gif.
     * @param {Number} opts.quality Source resolution to use (default to highest quality)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    getFrameWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getFrame");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'frames': this.apiClient.buildCollectionParam(opts['frames'], 'csv'),
        'tile': opts['tile'],
        'roi': opts['roi'],
        'force_scale': opts['forceScale'],
        'animate': opts['animate'],
        'quality': opts['quality']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['image/*'];
      let returnType = File;
      return this.apiClient.callApi(
        '/rest/GetFrame/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get frame(s) from a video.  Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.frames Comma-seperated list of frames to capture.
     * @param {String} opts.tile wxh, if not supplied is made as squarish as possible.
     * @param {String} opts.roi w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
     * @param {String} opts.forceScale Size of each frame image to return in format wxh. This forces scaling the image. Applied after ROI crop if any.Default is the size of the frame for highest streaming resolution. Example: 1024x768
     * @param {Number} opts.animate If not tiling, animate each frame at a given fps in a gif.
     * @param {Number} opts.quality Source resolution to use (default to highest quality)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    getFrame(id, opts) {
      return this.getFrameWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of images for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/ImageDefinition} and HTTP response
     */
    getImageFileWithHttpInfo(id, role, index) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getImageFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling getImageFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling getImageFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ImageDefinition;
      return this.apiClient.callApi(
        '/rest/ImageFile/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of images for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ImageDefinition}
     */
    getImageFile(id, role, index) {
      return this.getImageFileWithHttpInfo(id, role, index)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get image file list.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/ImageDefinition>} and HTTP response
     */
    getImageFileListWithHttpInfo(id, role) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getImageFileList");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling getImageFileList");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ImageDefinition];
      return this.apiClient.callApi(
        '/rest/ImageFiles/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get image file list.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/ImageDefinition>}
     */
    getImageFileList(id, role) {
      return this.getImageFileListWithHttpInfo(id, role)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} id A unique integer identifying a invitation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Invitation} and HTTP response
     */
    getInvitationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getInvitation");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Invitation;
      return this.apiClient.callApi(
        '/rest/Invitation/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} id A unique integer identifying a invitation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Invitation}
     */
    getInvitation(id) {
      return this.getInvitationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get invitation list.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} organization A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Invitation>} and HTTP response
     */
    getInvitationListWithHttpInfo(organization) {
      let postBody = null;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling getInvitationList");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Invitation];
      return this.apiClient.callApi(
        '/rest/Invitations/{organization}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get invitation list.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} organization A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Invitation>}
     */
    getInvitationList(organization) {
      return this.getInvitationListWithHttpInfo(organization)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to get a job's status using the `uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {String} uid A uuid1 string identifying to single Job.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Job} and HTTP response
     */
    getJobWithHttpInfo(uid) {
      let postBody = null;
      // verify the required parameter 'uid' is set
      if (uid === undefined || uid === null) {
        throw new Error("Missing the required parameter 'uid' when calling getJob");
      }

      let pathParams = {
        'uid': uid
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Job;
      return this.apiClient.callApi(
        '/rest/Job/{uid}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to get a job's status using the `uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {String} uid A uuid1 string identifying to single Job.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Job}
     */
    getJob(uid) {
      return this.getJobWithHttpInfo(uid)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get registered job cluster
     * @param {Number} id A unique integer identifying a registered job cluster.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/JobCluster} and HTTP response
     */
    getJobClusterWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getJobCluster");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = JobCluster;
      return this.apiClient.callApi(
        '/rest/JobCluster/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get registered job cluster
     * @param {Number} id A unique integer identifying a registered job cluster.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobCluster}
     */
    getJobCluster(id) {
      return this.getJobClusterWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     *  Get job clusters. 
     * @param {Number} id A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/JobCluster>} and HTTP response
     */
    getJobClusterListWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getJobClusterList");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [JobCluster];
      return this.apiClient.callApi(
        '/rest/JobClusters/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     *  Get job clusters. 
     * @param {Number} id A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/JobCluster>}
     */
    getJobClusterList(id) {
      return this.getJobClusterListWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get background job list.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to status for a list of jobs in a project that were created by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.gid A UUID string identifying a group of jobs.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Job>} and HTTP response
     */
    getJobListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getJobList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'gid': opts['gid']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Job];
      return this.apiClient.callApi(
        '/rest/Jobs/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get background job list.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.   This method allows the user to status for a list of jobs in a project that were created by either the `AlgorithmLaunch` or `Transcode` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.gid A UUID string identifying a group of jobs.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Job>}
     */
    getJobList(project, opts) {
      return this.getJobListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
     * @param {Number} id A unique integer identifying a leaf.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Leaf} and HTTP response
     */
    getLeafWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getLeaf");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Leaf;
      return this.apiClient.callApi(
        '/rest/Leaf/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
     * @param {Number} id A unique integer identifying a leaf.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Leaf}
     */
    getLeaf(id) {
      return this.getLeafWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `Leaves` endpoint, but only returns the number of leaves. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getLeafCountWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLeafCount");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'type': opts['type'],
        'name': opts['name'],
        'depth': opts['depth'],
        'leaf_id': this.apiClient.buildCollectionParam(opts['leafId'], 'multi'),
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/LeafCount/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `Leaves` endpoint, but only returns the number of leaves. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getLeafCount(project, opts) {
      return this.getLeafCountWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the `Leaves` endpoint, but only returns the number of leaves. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafIdQuery} leafIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getLeafCountByIdWithHttpInfo(project, leafIdQuery, opts) {
      opts = opts || {};
      let postBody = leafIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLeafCountById");
      }
      // verify the required parameter 'leafIdQuery' is set
      if (leafIdQuery === undefined || leafIdQuery === null) {
        throw new Error("Missing the required parameter 'leafIdQuery' when calling getLeafCountById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'type': opts['type'],
        'name': opts['name'],
        'depth': opts['depth'],
        'leaf_id': this.apiClient.buildCollectionParam(opts['leafId'], 'multi'),
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/LeafCount/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the `Leaves` endpoint, but only returns the number of leaves. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafIdQuery} leafIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getLeafCountById(project, leafIdQuery, opts) {
      return this.getLeafCountByIdWithHttpInfo(project, leafIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Leaf>} and HTTP response
     */
    getLeafListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLeafList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'type': opts['type'],
        'name': opts['name'],
        'depth': opts['depth'],
        'leaf_id': this.apiClient.buildCollectionParam(opts['leafId'], 'multi'),
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Leaf];
      return this.apiClient.callApi(
        '/rest/Leaves/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Leaf>}
     */
    getLeafList(project, opts) {
      return this.getLeafListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf list by ID.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafIdQuery} leafIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Leaf>} and HTTP response
     */
    getLeafListByIdWithHttpInfo(project, leafIdQuery, opts) {
      opts = opts || {};
      let postBody = leafIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLeafListById");
      }
      // verify the required parameter 'leafIdQuery' is set
      if (leafIdQuery === undefined || leafIdQuery === null) {
        throw new Error("Missing the required parameter 'leafIdQuery' when calling getLeafListById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'type': opts['type'],
        'name': opts['name'],
        'depth': opts['depth'],
        'leaf_id': this.apiClient.buildCollectionParam(opts['leafId'], 'multi'),
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [Leaf];
      return this.apiClient.callApi(
        '/rest/Leaves/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf list by ID.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafIdQuery} leafIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Leaf>}
     */
    getLeafListById(project, leafIdQuery, opts) {
      return this.getLeafListByIdWithHttpInfo(project, leafIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} id A unique integer identifying an leaf type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/LeafType} and HTTP response
     */
    getLeafTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getLeafType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = LeafType;
      return this.apiClient.callApi(
        '/rest/LeafType/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} id A unique integer identifying an leaf type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/LeafType}
     */
    getLeafType(id) {
      return this.getLeafTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get leaf type list.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/LeafType>} and HTTP response
     */
    getLeafTypeListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLeafTypeList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [LeafType];
      return this.apiClient.callApi(
        '/rest/LeafTypes/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get leaf type list.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/LeafType>}
     */
    getLeafTypeList(project) {
      return this.getLeafTypeListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a localization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Localization} and HTTP response
     */
    getLocalizationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getLocalization");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Localization;
      return this.apiClient.callApi(
        '/rest/Localization/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a localization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Localization}
     */
    getLocalization(id) {
      return this.getLocalizationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `Localizations` endpoint, but only returns the number of localizations. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getLocalizationCountWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLocalizationCount");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/LocalizationCount/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `Localizations` endpoint, but only returns the number of localizations. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getLocalizationCount(project, opts) {
      return this.getLocalizationCountWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the `Localizations` endpoint, but only returns the number of localizations. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationIdQuery} localizationIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getLocalizationCountByIdWithHttpInfo(project, localizationIdQuery, opts) {
      opts = opts || {};
      let postBody = localizationIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLocalizationCountById");
      }
      // verify the required parameter 'localizationIdQuery' is set
      if (localizationIdQuery === undefined || localizationIdQuery === null) {
        throw new Error("Missing the required parameter 'localizationIdQuery' when calling getLocalizationCountById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/LocalizationCount/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the `Localizations` endpoint, but only returns the number of localizations. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationIdQuery} localizationIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getLocalizationCountById(project, localizationIdQuery, opts) {
      return this.getLocalizationCountByIdWithHttpInfo(project, localizationIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization graphic from a media object. 
     * @param {Number} id A unique integer identifying a localization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.forceScale Size of final image to return. This forces scaling the image. Default is the localization size and margins define the image size. Example: 100x100 
     * @param {Boolean} opts.useDefaultMargins Use default margins for localization types.  Default margins (x,y pixels) - dot: (10,10) line:  (10,10) box: (0,0)  (default to true)
     * @param {Number} opts.marginX Pixel margin to apply to the height of the localization when generating the image. Valid only if use_default_margins is false. 
     * @param {Number} opts.marginY Pixel margin to apply to the width of the localization when generating the image. Valid only if use_default_margins is false. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    getLocalizationGraphicWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getLocalizationGraphic");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'force_scale': opts['forceScale'],
        'use_default_margins': opts['useDefaultMargins'],
        'margin_x': opts['marginX'],
        'margin_y': opts['marginY']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['image/*'];
      let returnType = File;
      return this.apiClient.callApi(
        '/rest/LocalizationGraphic/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization graphic from a media object. 
     * @param {Number} id A unique integer identifying a localization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.forceScale Size of final image to return. This forces scaling the image. Default is the localization size and margins define the image size. Example: 100x100 
     * @param {Boolean} opts.useDefaultMargins Use default margins for localization types.  Default margins (x,y pixels) - dot: (10,10) line:  (10,10) box: (0,0)  (default to true)
     * @param {Number} opts.marginX Pixel margin to apply to the height of the localization when generating the image. Valid only if use_default_margins is false. 
     * @param {Number} opts.marginY Pixel margin to apply to the width of the localization when generating the image. Valid only if use_default_margins is false. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    getLocalizationGraphic(id, opts) {
      return this.getLocalizationGraphicWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Localization>} and HTTP response
     */
    getLocalizationListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLocalizationList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs'],
        'excludeParents': opts['excludeParents'],
        'frame': opts['frame']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Localization];
      return this.apiClient.callApi(
        '/rest/Localizations/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Localization>}
     */
    getLocalizationList(project, opts) {
      return this.getLocalizationListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization list by ID.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationIdQuery} localizationIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Localization>} and HTTP response
     */
    getLocalizationListByIdWithHttpInfo(project, localizationIdQuery, opts) {
      opts = opts || {};
      let postBody = localizationIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLocalizationListById");
      }
      // verify the required parameter 'localizationIdQuery' is set
      if (localizationIdQuery === undefined || localizationIdQuery === null) {
        throw new Error("Missing the required parameter 'localizationIdQuery' when calling getLocalizationListById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs'],
        'excludeParents': opts['excludeParents'],
        'frame': opts['frame']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [Localization];
      return this.apiClient.callApi(
        '/rest/Localizations/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization list by ID.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationIdQuery} localizationIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Localization>}
     */
    getLocalizationListById(project, localizationIdQuery, opts) {
      return this.getLocalizationListByIdWithHttpInfo(project, localizationIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a localization type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/LocalizationType} and HTTP response
     */
    getLocalizationTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getLocalizationType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = LocalizationType;
      return this.apiClient.callApi(
        '/rest/LocalizationType/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a localization type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/LocalizationType}
     */
    getLocalizationType(id) {
      return this.getLocalizationTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get localization type list.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of unique integers identifying a media.
     * @param {Number} opts.type Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/LocalizationType>} and HTTP response
     */
    getLocalizationTypeListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getLocalizationTypeList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [LocalizationType];
      return this.apiClient.callApi(
        '/rest/LocalizationTypes/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get localization type list.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of unique integers identifying a media.
     * @param {Number} opts.type Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/LocalizationType>}
     */
    getLocalizationTypeList(project, opts) {
      return this.getLocalizationTypeListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} id A unique integer identifying a media.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.presigned If given, all `path` fields in `media_files` will be replaced with presigned URLs that can be downloaded without authentication. The value is the expiration time of the URLs in seconds.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Media} and HTTP response
     */
    getMediaWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getMedia");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'presigned': opts['presigned']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Media;
      return this.apiClient.callApi(
        '/rest/Media/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} id A unique integer identifying a media.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.presigned If given, all `path` fields in `media_files` will be replaced with presigned URLs that can be downloaded without authentication. The value is the expiration time of the URLs in seconds.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Media}
     */
    getMedia(id, opts) {
      return this.getMediaWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media list count.  This endpoint accepts the same query parameters as a GET or PUT request to the  `Medias` endpoint, but only returns the number of media. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getMediaCountWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMediaCount");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/MediaCount/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media list count.  This endpoint accepts the same query parameters as a GET or PUT request to the  `Medias` endpoint, but only returns the number of media. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getMediaCount(project, opts) {
      return this.getMediaCountWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the  `Medias` endpoint, but only returns the number of media. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaIdQuery} mediaIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getMediaCountByIdWithHttpInfo(project, mediaIdQuery, opts) {
      opts = opts || {};
      let postBody = mediaIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMediaCountById");
      }
      // verify the required parameter 'mediaIdQuery' is set
      if (mediaIdQuery === undefined || mediaIdQuery === null) {
        throw new Error("Missing the required parameter 'mediaIdQuery' when calling getMediaCountById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/MediaCount/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the  `Medias` endpoint, but only returns the number of media. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaIdQuery} mediaIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getMediaCountById(project, mediaIdQuery, opts) {
      return this.getMediaCountByIdWithHttpInfo(project, mediaIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.presigned If given, all `path` fields in `media_files` will be replaced with presigned URLs that can be downloaded without authentication. The value is the expiration time of the URLs in seconds.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Media>} and HTTP response
     */
    getMediaListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMediaList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs'],
        'presigned': opts['presigned']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Media];
      return this.apiClient.callApi(
        '/rest/Medias/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.presigned If given, all `path` fields in `media_files` will be replaced with presigned URLs that can be downloaded without authentication. The value is the expiration time of the URLs in seconds.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Media>}
     */
    getMediaList(project, opts) {
      return this.getMediaListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media list by ID.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaIdQuery} mediaIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.presigned If given, all `path` fields in `media_files` will be replaced with presigned URLs that can be downloaded without authentication. The value is the expiration time of the URLs in seconds.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Media>} and HTTP response
     */
    getMediaListByIdWithHttpInfo(project, mediaIdQuery, opts) {
      opts = opts || {};
      let postBody = mediaIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMediaListById");
      }
      // verify the required parameter 'mediaIdQuery' is set
      if (mediaIdQuery === undefined || mediaIdQuery === null) {
        throw new Error("Missing the required parameter 'mediaIdQuery' when calling getMediaListById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs'],
        'presigned': opts['presigned']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [Media];
      return this.apiClient.callApi(
        '/rest/Medias/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media list by ID.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaIdQuery} mediaIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.presigned If given, all `path` fields in `media_files` will be replaced with presigned URLs that can be downloaded without authentication. The value is the expiration time of the URLs in seconds.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Media>}
     */
    getMediaListById(project, mediaIdQuery, opts) {
      return this.getMediaListByIdWithHttpInfo(project, mediaIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MediaNext} and HTTP response
     */
    getMediaNextWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getMediaNext");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MediaNext;
      return this.apiClient.callApi(
        '/rest/MediaNext/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MediaNext}
     */
    getMediaNext(id, opts) {
      return this.getMediaNextWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MediaPrev} and HTTP response
     */
    getMediaPrevWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getMediaPrev");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MediaPrev;
      return this.apiClient.callApi(
        '/rest/MediaPrev/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MediaPrev}
     */
    getMediaPrev(id, opts) {
      return this.getMediaPrevWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve count, download size, total size, and duration of a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns statistics about the media. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MediaStats} and HTTP response
     */
    getMediaStatsWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMediaStats");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MediaStats;
      return this.apiClient.callApi(
        '/rest/MediaStats/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve count, download size, total size, and duration of a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns statistics about the media. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MediaStats}
     */
    getMediaStats(project, opts) {
      return this.getMediaStatsWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying an media type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MediaType} and HTTP response
     */
    getMediaTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getMediaType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = MediaType;
      return this.apiClient.callApi(
        '/rest/MediaType/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying an media type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MediaType}
     */
    getMediaType(id) {
      return this.getMediaTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get media type list.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/MediaType>} and HTTP response
     */
    getMediaTypeListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMediaTypeList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [MediaType];
      return this.apiClient.callApi(
        '/rest/MediaTypes/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get media type list.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/MediaType>}
     */
    getMediaTypeList(project) {
      return this.getMediaTypeListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} id A unique integer identifying a membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Membership} and HTTP response
     */
    getMembershipWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getMembership");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Membership;
      return this.apiClient.callApi(
        '/rest/Membership/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} id A unique integer identifying a membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Membership}
     */
    getMembership(id) {
      return this.getMembershipWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get membership list.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Membership>} and HTTP response
     */
    getMembershipListWithHttpInfo(project) {
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getMembershipList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Membership];
      return this.apiClient.callApi(
        '/rest/Memberships/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get membership list.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} project A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Membership>}
     */
    getMembershipList(project) {
      return this.getMembershipListWithHttpInfo(project)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   
     * @param {Number} id A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Organization} and HTTP response
     */
    getOrganizationWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getOrganization");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Organization;
      return this.apiClient.callApi(
        '/rest/Organization/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   
     * @param {Number} id A unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Organization}
     */
    getOrganization(id) {
      return this.getOrganizationWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get organization list.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   Returns all organizations that a user is affiliated with.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Organization>} and HTTP response
     */
    getOrganizationListWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Organization];
      return this.apiClient.callApi(
        '/rest/Organizations', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get organization list.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   Returns all organizations that a user is affiliated with.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Organization>}
     */
    getOrganizationList() {
      return this.getOrganizationListWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve URL for file upload to a given organization. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expiration Number of seconds until URL expires and becomes invalid. (default to 86400)
     * @param {Number} opts.numParts Number of upload parts. Maximum part size is 5GB. (default to 1)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/UploadInfo} and HTTP response
     */
    getOrganizationUploadInfoWithHttpInfo(organization, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'organization' is set
      if (organization === undefined || organization === null) {
        throw new Error("Missing the required parameter 'organization' when calling getOrganizationUploadInfo");
      }

      let pathParams = {
        'organization': organization
      };
      let queryParams = {
        'expiration': opts['expiration'],
        'num_parts': opts['numParts']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = UploadInfo;
      return this.apiClient.callApi(
        '/rest/OrganizationUploadInfo/{organization}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve URL for file upload to a given organization. 
     * @param {Number} organization A unique integer identifying an organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expiration Number of seconds until URL expires and becomes invalid. (default to 86400)
     * @param {Number} opts.numParts Number of upload parts. Maximum part size is 5GB. (default to 1)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UploadInfo}
     */
    getOrganizationUploadInfo(organization, opts) {
      return this.getOrganizationUploadInfoWithHttpInfo(organization, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get permalink  A Permalink allows persistant access to an underlying media resource via a persistent URL.   
     * @param {Number} id A unique integer identifying a media.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.element Object to redirect to via 301. (default to 'auto')
     * @param {Number} opts.quality Find the object with the closest quality (ignored for audio) (default to 720)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    getPermalinkWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getPermalink");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'element': opts['element'],
        'quality': opts['quality']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Permalink/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get permalink  A Permalink allows persistant access to an underlying media resource via a persistent URL.   
     * @param {Number} id A unique integer identifying a media.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.element Object to redirect to via 301. (default to 'auto')
     * @param {Number} opts.quality Find the object with the closest quality (ignored for audio) (default to 720)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    getPermalink(id, opts) {
      return this.getPermalinkWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
     * @param {Number} id A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Project} and HTTP response
     */
    getProjectWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getProject");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Project;
      return this.apiClient.callApi(
        '/rest/Project/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
     * @param {Number} id A unique integer identifying a project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Project}
     */
    getProject(id) {
      return this.getProjectWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get project list.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Returns all projects that a user has access to.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.organization Unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Project>} and HTTP response
     */
    getProjectListWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'organization': opts['organization']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Project];
      return this.apiClient.callApi(
        '/rest/Projects', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get project list.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   Returns all projects that a user has access to.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.organization Unique integer identifying an organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Project>}
     */
    getProjectList(opts) {
      return this.getProjectListWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media. 
     * @param {Number} id A unique integer identifying a section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Section} and HTTP response
     */
    getSectionWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getSection");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Section;
      return this.apiClient.callApi(
        '/rest/Section/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media. 
     * @param {Number} id A unique integer identifying a section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Section}
     */
    getSection(id) {
      return this.getSectionWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve analysis results for a media list.  This endpoint uses objects created with the `Analysis` endpoint to perform analysis on filtered media lists. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Object.<String, module:model/{String: AttributeValue}>} and HTTP response
     */
    getSectionAnalysisWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getSectionAnalysis");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = {'String': AttributeValue};
      return this.apiClient.callApi(
        '/rest/SectionAnalysis/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve analysis results for a media list.  This endpoint uses objects created with the `Analysis` endpoint to perform analysis on filtered media lists. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Object.<String, module:model/{String: AttributeValue}>}
     */
    getSectionAnalysis(project, opts) {
      return this.getSectionAnalysisWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get section list.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Section>} and HTTP response
     */
    getSectionListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getSectionList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'name': opts['name']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Section];
      return this.apiClient.callApi(
        '/rest/Sections/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get section list.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.name Name of the section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Section>}
     */
    getSectionList(project, opts) {
      return this.getSectionListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a state.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/State} and HTTP response
     */
    getStateWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getState");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = State;
      return this.apiClient.callApi(
        '/rest/State/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a state.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/State}
     */
    getState(id) {
      return this.getStateWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `States` endpoint, but only returns the number of states. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getStateCountWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getStateCount");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/StateCount/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state list count.  This endpoint accepts the same query parameters as a GET or PUT request to the `States` endpoint, but only returns the number of states. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getStateCount(project, opts) {
      return this.getStateCountWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the `States` endpoint, but only returns the number of states. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateIdQuery} stateIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Number} and HTTP response
     */
    getStateCountByIdWithHttpInfo(project, stateIdQuery, opts) {
      opts = opts || {};
      let postBody = stateIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getStateCountById");
      }
      // verify the required parameter 'stateIdQuery' is set
      if (stateIdQuery === undefined || stateIdQuery === null) {
        throw new Error("Missing the required parameter 'stateIdQuery' when calling getStateCountById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = 'Number';
      return this.apiClient.callApi(
        '/rest/StateCount/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state list count by ID.  This endpoint accepts the same query parameters as a GET or PUT request to the `States` endpoint, but only returns the number of states. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateIdQuery} stateIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Number}
     */
    getStateCountById(project, stateIdQuery, opts) {
      return this.getStateCountByIdWithHttpInfo(project, stateIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     *  Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg. A maximum of 100 detections may be retrieved at once. Use the length and offset parameters to  control which section of a state is retrieved. 
     * @param {Number} id A unique integer identifying a state.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.mode Whether to animate or tile. (default to 'animate')
     * @param {Number} opts.fps Frame rate if `mode` is `animate`. (default to 2)
     * @param {String} opts.forceScale wxh to force each tile prior to stich (default to '224x224')
     * @param {Number} opts.length Number of detections to extract. (default to 100)
     * @param {Number} opts.offset Index offset of detections to extract. (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    getStateGraphicWithHttpInfo(id, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getStateGraphic");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'mode': opts['mode'],
        'fps': opts['fps'],
        'forceScale': opts['forceScale'],
        'length': opts['length'],
        'offset': opts['offset']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['image/*'];
      let returnType = File;
      return this.apiClient.callApi(
        '/rest/StateGraphic/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     *  Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg. A maximum of 100 detections may be retrieved at once. Use the length and offset parameters to  control which section of a state is retrieved. 
     * @param {Number} id A unique integer identifying a state.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.mode Whether to animate or tile. (default to 'animate')
     * @param {Number} opts.fps Frame rate if `mode` is `animate`. (default to 2)
     * @param {String} opts.forceScale wxh to force each tile prior to stich (default to '224x224')
     * @param {Number} opts.length Number of detections to extract. (default to 100)
     * @param {Number} opts.offset Index offset of detections to extract. (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    getStateGraphic(id, opts) {
      return this.getStateGraphicWithHttpInfo(id, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/State>} and HTTP response
     */
    getStateListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getStateList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [State];
      return this.apiClient.callApi(
        '/rest/States/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/State>}
     */
    getStateList(project, opts) {
      return this.getStateListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state list by ID.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateIdQuery} stateIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/State>} and HTTP response
     */
    getStateListByIdWithHttpInfo(project, stateIdQuery, opts) {
      opts = opts || {};
      let postBody = stateIdQuery;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getStateListById");
      }
      // verify the required parameter 'stateIdQuery' is set
      if (stateIdQuery === undefined || stateIdQuery === null) {
        throw new Error("Missing the required parameter 'stateIdQuery' when calling getStateListById");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = [State];
      return this.apiClient.callApi(
        '/rest/States/{project}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state list by ID.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateIdQuery} stateIdQuery 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/State>}
     */
    getStateListById(project, stateIdQuery, opts) {
      return this.getStateListByIdWithHttpInfo(project, stateIdQuery, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a state type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/StateType} and HTTP response
     */
    getStateTypeWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getStateType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = StateType;
      return this.apiClient.callApi(
        '/rest/StateType/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a state type.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StateType}
     */
    getStateType(id) {
      return this.getStateTypeWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get state type list.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of unique integers identifying a media.
     * @param {Number} opts.type Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/StateType>} and HTTP response
     */
    getStateTypeListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getStateTypeList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [StateType];
      return this.apiClient.callApi(
        '/rest/StateTypes/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get state type list.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of unique integers identifying a media.
     * @param {Number} opts.type Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/StateType>}
     */
    getStateTypeList(project, opts) {
      return this.getStateTypeListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get temporary file.  Temporary files are files stored server side for a defined duration. 
     * @param {Number} id A unique integer identifying a temporary file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/TemporaryFile} and HTTP response
     */
    getTemporaryFileWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getTemporaryFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = TemporaryFile;
      return this.apiClient.callApi(
        '/rest/TemporaryFile/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get temporary file.  Temporary files are files stored server side for a defined duration. 
     * @param {Number} id A unique integer identifying a temporary file.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TemporaryFile}
     */
    getTemporaryFile(id) {
      return this.getTemporaryFileWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get temporary file list.  Temporary files are files stored server side for a defined duration.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expired If greater than 0 will return only expired files (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/TemporaryFile>} and HTTP response
     */
    getTemporaryFileListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getTemporaryFileList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'expired': opts['expired']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [TemporaryFile];
      return this.apiClient.callApi(
        '/rest/TemporaryFiles/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get temporary file list.  Temporary files are files stored server side for a defined duration.   
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expired If greater than 0 will return only expired files (default to 0)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/TemporaryFile>}
     */
    getTemporaryFileList(project, opts) {
      return this.getTemporaryFileListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve URL for file upload to a given project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expiration Number of seconds until URL expires and becomes invalid. (default to 86400)
     * @param {Number} opts.numParts Number of upload parts. Maximum part size is 5GB. (default to 1)
     * @param {Number} opts.mediaId Media ID if this is an upload for existing media.
     * @param {Number} opts.fileId File ID if this is an upload for existing file.
     * @param {String} opts.filename Filename to use if `media_id` is given. If a file with the same name already exists under the given media ID prefix, the new upload will replace it. Ignored if `media_id` is not given.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/UploadInfo} and HTTP response
     */
    getUploadInfoWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getUploadInfo");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'expiration': opts['expiration'],
        'num_parts': opts['numParts'],
        'media_id': opts['mediaId'],
        'file_id': opts['fileId'],
        'filename': opts['filename']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = UploadInfo;
      return this.apiClient.callApi(
        '/rest/UploadInfo/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve URL for file upload to a given project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.expiration Number of seconds until URL expires and becomes invalid. (default to 86400)
     * @param {Number} opts.numParts Number of upload parts. Maximum part size is 5GB. (default to 1)
     * @param {Number} opts.mediaId Media ID if this is an upload for existing media.
     * @param {Number} opts.fileId File ID if this is an upload for existing file.
     * @param {String} opts.filename Filename to use if `media_id` is given. If a file with the same name already exists under the given media ID prefix, the new upload will replace it. Ignored if `media_id` is not given.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UploadInfo}
     */
    getUploadInfo(project, opts) {
      return this.getUploadInfoWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.   
     * @param {Number} id A unique integer identifying a version.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Version} and HTTP response
     */
    getVersionWithHttpInfo(id) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getVersion");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = Version;
      return this.apiClient.callApi(
        '/rest/Version/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.   
     * @param {Number} id A unique integer identifying a version.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Version}
     */
    getVersion(id) {
      return this.getVersionWithHttpInfo(id)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get version list.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.mediaId Unique integer identifying a media.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/Version>} and HTTP response
     */
    getVersionListWithHttpInfo(project, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling getVersionList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': opts['mediaId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [Version];
      return this.apiClient.callApi(
        '/rest/Versions/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get version list.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions. 
     * @param {Number} project A unique integer identifying a project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.mediaId Unique integer identifying a media.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/Version>}
     */
    getVersionList(project, opts) {
      return this.getVersionListWithHttpInfo(project, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of videos for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/VideoDefinition} and HTTP response
     */
    getVideoFileWithHttpInfo(id, role, index) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getVideoFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling getVideoFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling getVideoFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = VideoDefinition;
      return this.apiClient.callApi(
        '/rest/VideoFile/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of videos for the specified `role`.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/VideoDefinition}
     */
    getVideoFile(id, role, index) {
      return this.getVideoFileWithHttpInfo(id, role, index)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get video file list.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/VideoDefinition>} and HTTP response
     */
    getVideoFileListWithHttpInfo(id, role) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getVideoFileList");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling getVideoFileList");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [VideoDefinition];
      return this.apiClient.callApi(
        '/rest/VideoFiles/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get video file list.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/VideoDefinition>}
     */
    getVideoFileList(id, role) {
      return this.getVideoFileListWithHttpInfo(id, role)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get list of autocomplete suggestions.  This endpoint is compatible with [devbridge suggestion format](https://github.com/kraaden/autocomplete) . It performs a glob search on leaf objects in the project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {String} ancestor Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
     * @param {String} query String to search for matching names.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.minLevel Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Array.<module:model/LeafSuggestion>} and HTTP response
     */
    leafSuggestionWithHttpInfo(project, ancestor, query, opts) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling leafSuggestion");
      }
      // verify the required parameter 'ancestor' is set
      if (ancestor === undefined || ancestor === null) {
        throw new Error("Missing the required parameter 'ancestor' when calling leafSuggestion");
      }
      // verify the required parameter 'query' is set
      if (query === undefined || query === null) {
        throw new Error("Missing the required parameter 'query' when calling leafSuggestion");
      }

      let pathParams = {
        'project': project,
        'ancestor': ancestor
      };
      let queryParams = {
        'minLevel': opts['minLevel'],
        'query': query
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [LeafSuggestion];
      return this.apiClient.callApi(
        '/rest/Leaves/Suggestion/{ancestor}/{project}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get list of autocomplete suggestions.  This endpoint is compatible with [devbridge suggestion format](https://github.com/kraaden/autocomplete) . It performs a glob search on leaf objects in the project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {String} ancestor Get descendents of a leaf element (inclusive), by path (i.e. ITIS.Animalia).
     * @param {String} query String to search for matching names.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.minLevel Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Array.<module:model/LeafSuggestion>}
     */
    leafSuggestion(project, ancestor, query, opts) {
      return this.leafSuggestionWithHttpInfo(project, ancestor, query, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Merges the source state into the target state.  The target state will inherit the the source's localizations and will be deleted. 
     * @param {Number} id A unique integer identifying the target state to accept the merge.
     * @param {module:model/StateMergeUpdate} stateMergeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    mergeStatesWithHttpInfo(id, stateMergeUpdate) {
      let postBody = stateMergeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling mergeStates");
      }
      // verify the required parameter 'stateMergeUpdate' is set
      if (stateMergeUpdate === undefined || stateMergeUpdate === null) {
        throw new Error("Missing the required parameter 'stateMergeUpdate' when calling mergeStates");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/MergeStates/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Merges the source state into the target state.  The target state will inherit the the source's localizations and will be deleted. 
     * @param {Number} id A unique integer identifying the target state to accept the merge.
     * @param {module:model/StateMergeUpdate} stateMergeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    mergeStates(id, stateMergeUpdate) {
      return this.mergeStatesWithHttpInfo(id, stateMergeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment's settings. 
     * @param {module:model/NotifySpec} notifySpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    notifyWithHttpInfo(notifySpec) {
      let postBody = notifySpec;
      // verify the required parameter 'notifySpec' is set
      if (notifySpec === undefined || notifySpec === null) {
        throw new Error("Missing the required parameter 'notifySpec' when calling notify");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Notify', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment's settings. 
     * @param {module:model/NotifySpec} notifySpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    notify(notifySpec) {
      return this.notifyWithHttpInfo(notifySpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Register an algorithm argo workflow.  This endpoint replicates the algorithm registration through the admin portal. The provided manifest file must have been uploaded and saved by the SaveAlgorithmManifest endpoint. This endpoint will respond with an error if one of the following conditions occur:  - Provided workflow name is not unique (across projects) - Not all the required fields are present - There are syntax errors with the given manifest file 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AlgorithmSpec} algorithmSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    registerAlgorithmWithHttpInfo(project, algorithmSpec) {
      let postBody = algorithmSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling registerAlgorithm");
      }
      // verify the required parameter 'algorithmSpec' is set
      if (algorithmSpec === undefined || algorithmSpec === null) {
        throw new Error("Missing the required parameter 'algorithmSpec' when calling registerAlgorithm");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Algorithms/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Register an algorithm argo workflow.  This endpoint replicates the algorithm registration through the admin portal. The provided manifest file must have been uploaded and saved by the SaveAlgorithmManifest endpoint. This endpoint will respond with an error if one of the following conditions occur:  - Provided workflow name is not unique (across projects) - Not all the required fields are present - There are syntax errors with the given manifest file 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AlgorithmSpec} algorithmSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    registerAlgorithm(project, algorithmSpec) {
      return this.registerAlgorithmWithHttpInfo(project, algorithmSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create applet.  Applets are customized interfaces (i.e. html files) displayed within the Tator projects. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AppletSpec} appletSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/CreateResponse} and HTTP response
     */
    registerAppletWithHttpInfo(project, appletSpec) {
      let postBody = appletSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling registerApplet");
      }
      // verify the required parameter 'appletSpec' is set
      if (appletSpec === undefined || appletSpec === null) {
        throw new Error("Missing the required parameter 'appletSpec' when calling registerApplet");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateResponse;
      return this.apiClient.callApi(
        '/rest/Applets/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create applet.  Applets are customized interfaces (i.e. html files) displayed within the Tator projects. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/AppletSpec} appletSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CreateResponse}
     */
    registerApplet(project, appletSpec) {
      return this.registerAppletWithHttpInfo(project, appletSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Renames and/or changes the type of an existing attribute on Type.  A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeUpdate} attributeTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    renameAttributeWithHttpInfo(id, attributeTypeUpdate) {
      let postBody = attributeTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling renameAttribute");
      }
      // verify the required parameter 'attributeTypeUpdate' is set
      if (attributeTypeUpdate === undefined || attributeTypeUpdate === null) {
        throw new Error("Missing the required parameter 'attributeTypeUpdate' when calling renameAttribute");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AttributeType/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Renames and/or changes the type of an existing attribute on Type.  A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeUpdate} attributeTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    renameAttribute(id, attributeTypeUpdate) {
      return this.renameAttributeWithHttpInfo(id, attributeTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     *  Replaces the definition of an existing attribute on Type.  WARNING This completely replaces the existing definition and will delete any existing fields that are not present in the `new_attribute_type` definition.               A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeUpdate} attributeTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    replaceAttributeWithHttpInfo(id, attributeTypeUpdate) {
      let postBody = attributeTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling replaceAttribute");
      }
      // verify the required parameter 'attributeTypeUpdate' is set
      if (attributeTypeUpdate === undefined || attributeTypeUpdate === null) {
        throw new Error("Missing the required parameter 'attributeTypeUpdate' when calling replaceAttribute");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AttributeType/{id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     *  Replaces the definition of an existing attribute on Type.  WARNING This completely replaces the existing definition and will delete any existing fields that are not present in the `new_attribute_type` definition.               A attribute type is the metadata definition object for a user-defined attribute. It includes name, type, and any other associated fields, depending on the type. 
     * @param {Number} id A unique integer identifying a unique entity type.
     * @param {module:model/AttributeTypeUpdate} attributeTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    replaceAttribute(id, attributeTypeUpdate) {
      return this.replaceAttributeWithHttpInfo(id, attributeTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Saves an uploaded algorithm manifest to the desired project. It is expected this manifest corresponds with an algorithm workflow to be registered by another endpoint.  Manifest is uploaded via tus, a separate mechanism from the REST API. Once a manifest upload is complete (a .yaml file), the file must be saved to the database using this endpoint. 
     * @param {Number} project A unique integer identifying a project
     * @param {module:model/AlgorithmManifestSpec} algorithmManifestSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/AlgorithmManifest} and HTTP response
     */
    saveAlgorithmManifestWithHttpInfo(project, algorithmManifestSpec) {
      let postBody = algorithmManifestSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling saveAlgorithmManifest");
      }
      // verify the required parameter 'algorithmManifestSpec' is set
      if (algorithmManifestSpec === undefined || algorithmManifestSpec === null) {
        throw new Error("Missing the required parameter 'algorithmManifestSpec' when calling saveAlgorithmManifest");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AlgorithmManifest;
      return this.apiClient.callApi(
        '/rest/SaveAlgorithmManifest/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Saves an uploaded algorithm manifest to the desired project. It is expected this manifest corresponds with an algorithm workflow to be registered by another endpoint.  Manifest is uploaded via tus, a separate mechanism from the REST API. Once a manifest upload is complete (a .yaml file), the file must be saved to the database using this endpoint. 
     * @param {Number} project A unique integer identifying a project
     * @param {module:model/AlgorithmManifestSpec} algorithmManifestSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AlgorithmManifest}
     */
    saveAlgorithmManifest(project, algorithmManifestSpec) {
      return this.saveAlgorithmManifestWithHttpInfo(project, algorithmManifestSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Saves an uploaded non-media file to the desired project's permanent storage. It is expected that this file will be used in conjunction with an applet. 
     * @param {Number} project A unique integer identifying a project
     * @param {module:model/GenericFileSpec} genericFileSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GenericFile} and HTTP response
     */
    saveGenericFileWithHttpInfo(project, genericFileSpec) {
      let postBody = genericFileSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling saveGenericFile");
      }
      // verify the required parameter 'genericFileSpec' is set
      if (genericFileSpec === undefined || genericFileSpec === null) {
        throw new Error("Missing the required parameter 'genericFileSpec' when calling saveGenericFile");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GenericFile;
      return this.apiClient.callApi(
        '/rest/SaveGenericFile/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Saves an uploaded non-media file to the desired project's permanent storage. It is expected that this file will be used in conjunction with an applet. 
     * @param {Number} project A unique integer identifying a project
     * @param {module:model/GenericFileSpec} genericFileSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GenericFile}
     */
    saveGenericFile(project, genericFileSpec) {
      return this.saveGenericFileWithHttpInfo(project, genericFileSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Send an email message using the Tator AWS SES configured credentials.'  Messages can only be sent to members of the same project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/EmailSpec} emailSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    sendEmailWithHttpInfo(project, emailSpec) {
      let postBody = emailSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling sendEmail");
      }
      // verify the required parameter 'emailSpec' is set
      if (emailSpec === undefined || emailSpec === null) {
        throw new Error("Missing the required parameter 'emailSpec' when calling sendEmail");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Email/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Send an email message using the Tator AWS SES configured credentials.'  Messages can only be sent to members of the same project. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/EmailSpec} emailSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    sendEmail(project, emailSpec) {
      return this.sendEmailWithHttpInfo(project, emailSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  `VideoFile`, `AudioFile`, and `ImageFile` endpoints. The transcode can be launched on an existing media object, or a media object will be created.  Transcodes may be cancelled via the `Job` or `JobGroup` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/TranscodeSpec} transcodeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Transcode} and HTTP response
     */
    transcodeWithHttpInfo(project, transcodeSpec) {
      let postBody = transcodeSpec;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling transcode");
      }
      // verify the required parameter 'transcodeSpec' is set
      if (transcodeSpec === undefined || transcodeSpec === null) {
        throw new Error("Missing the required parameter 'transcodeSpec' when calling transcode");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = Transcode;
      return this.apiClient.callApi(
        '/rest/Transcode/{project}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  `VideoFile`, `AudioFile`, and `ImageFile` endpoints. The transcode can be launched on an existing media object, or a media object will be created.  Transcodes may be cancelled via the `Job` or `JobGroup` endpoints. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/TranscodeSpec} transcodeSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Transcode}
     */
    transcode(project, transcodeSpec) {
      return this.transcodeWithHttpInfo(project, transcodeSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Trims the state's start or end point by deleting the localizations  before the new start point or after the new end point. 
     * @param {Number} id A unique integer identifying the state to trim
     * @param {module:model/StateTrimUpdate} stateTrimUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    trimStateEndWithHttpInfo(id, stateTrimUpdate) {
      let postBody = stateTrimUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling trimStateEnd");
      }
      // verify the required parameter 'stateTrimUpdate' is set
      if (stateTrimUpdate === undefined || stateTrimUpdate === null) {
        throw new Error("Missing the required parameter 'stateTrimUpdate' when calling trimStateEnd");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/TrimStateEnd/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Trims the state's start or end point by deleting the localizations  before the new start point or after the new end point. 
     * @param {Number} id A unique integer identifying the state to trim
     * @param {module:model/StateTrimUpdate} stateTrimUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    trimStateEnd(id, stateTrimUpdate) {
      return this.trimStateEndWithHttpInfo(id, stateTrimUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} id A unique integer identifying a affiliation.
     * @param {module:model/AffiliationUpdate} affiliationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateAffiliationWithHttpInfo(id, affiliationUpdate) {
      let postBody = affiliationUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateAffiliation");
      }
      // verify the required parameter 'affiliationUpdate' is set
      if (affiliationUpdate === undefined || affiliationUpdate === null) {
        throw new Error("Missing the required parameter 'affiliationUpdate' when calling updateAffiliation");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Affiliation/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update affiliation.  Affiliations specify a permission level of a user to an organization. There are currently two cumulative permission levels. `Member` can only view an organization and not change any data. `Admin` can modify an organization, add members to an organization, and create new projects under the organization's account. 
     * @param {Number} id A unique integer identifying a affiliation.
     * @param {module:model/AffiliationUpdate} affiliationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateAffiliation(id, affiliationUpdate) {
      return this.updateAffiliationWithHttpInfo(id, affiliationUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updated registered algorithm workflow
     * @param {Number} id A unique integer identifying a registered algorithm workflow.
     * @param {module:model/AlgorithmSpec} algorithmSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    updateAlgorithmWithHttpInfo(id, algorithmSpec) {
      let postBody = algorithmSpec;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateAlgorithm");
      }
      // verify the required parameter 'algorithmSpec' is set
      if (algorithmSpec === undefined || algorithmSpec === null) {
        throw new Error("Missing the required parameter 'algorithmSpec' when calling updateAlgorithm");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Algorithm/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updated registered algorithm workflow
     * @param {Number} id A unique integer identifying a registered algorithm workflow.
     * @param {module:model/AlgorithmSpec} algorithmSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    updateAlgorithm(id, algorithmSpec) {
      return this.updateAlgorithmWithHttpInfo(id, algorithmSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update analysis record
     * @param {Number} id A unique integer identifying an analysis record.
     * @param {module:model/AnalysisSpec} analysisSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateAnalysisWithHttpInfo(id, analysisSpec) {
      let postBody = analysisSpec;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateAnalysis");
      }
      // verify the required parameter 'analysisSpec' is set
      if (analysisSpec === undefined || analysisSpec === null) {
        throw new Error("Missing the required parameter 'analysisSpec' when calling updateAnalysis");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Analysis/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update analysis record
     * @param {Number} id A unique integer identifying an analysis record.
     * @param {module:model/AnalysisSpec} analysisSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateAnalysis(id, analysisSpec) {
      return this.updateAnalysisWithHttpInfo(id, analysisSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updated registered applet file
     * @param {Number} id A unique integer identifying a registered applet file.
     * @param {module:model/AppletSpec} appletSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    updateAppletWithHttpInfo(id, appletSpec) {
      let postBody = appletSpec;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateApplet");
      }
      // verify the required parameter 'appletSpec' is set
      if (appletSpec === undefined || appletSpec === null) {
        throw new Error("Missing the required parameter 'appletSpec' when calling updateApplet");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Applet/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updated registered applet file
     * @param {Number} id A unique integer identifying a registered applet file.
     * @param {module:model/AppletSpec} appletSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    updateApplet(id, appletSpec) {
      return this.updateAppletWithHttpInfo(id, appletSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of audio files for the specified `role`.
     * @param {module:model/AudioDefinition} audioDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateAudioFileWithHttpInfo(id, index, audioDefinition, opts) {
      opts = opts || {};
      let postBody = audioDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateAudioFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling updateAudioFile");
      }
      // verify the required parameter 'audioDefinition' is set
      if (audioDefinition === undefined || audioDefinition === null) {
        throw new Error("Missing the required parameter 'audioDefinition' when calling updateAudioFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AudioFile/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update audio file.  Audio files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying audio. One or more audio files can be used to reference the audio role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the audio file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of audio files for the specified `role`.
     * @param {module:model/AudioDefinition} audioDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'audio')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateAudioFile(id, index, audioDefinition, opts) {
      return this.updateAudioFileWithHttpInfo(id, index, audioDefinition, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update auxiliary file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of files for the specified `role`.
     * @param {module:model/AuxiliaryFileDefinition} auxiliaryFileDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateAuxiliaryFileWithHttpInfo(id, index, auxiliaryFileDefinition, opts) {
      opts = opts || {};
      let postBody = auxiliaryFileDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateAuxiliaryFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling updateAuxiliaryFile");
      }
      // verify the required parameter 'auxiliaryFileDefinition' is set
      if (auxiliaryFileDefinition === undefined || auxiliaryFileDefinition === null) {
        throw new Error("Missing the required parameter 'auxiliaryFileDefinition' when calling updateAuxiliaryFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': opts['role'],
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/AuxiliaryFile/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update auxiliary file.  Auxiliary files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying generic file. One or more files can be used to reference the attachment role in a `Media` object. The file itself must first be uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {Number} index Index of object. Must be less than size of current list of files for the specified `role`.
     * @param {module:model/AuxiliaryFileDefinition} auxiliaryFileDefinition 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.role Role of media file being referenced. (default to 'attachment')
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateAuxiliaryFile(id, index, auxiliaryFileDefinition, opts) {
      return this.updateAuxiliaryFileWithHttpInfo(id, index, auxiliaryFileDefinition, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} id A unique integer identifying a bookmark.
     * @param {module:model/BookmarkUpdate} bookmarkUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateBookmarkWithHttpInfo(id, bookmarkUpdate) {
      let postBody = bookmarkUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateBookmark");
      }
      // verify the required parameter 'bookmarkUpdate' is set
      if (bookmarkUpdate === undefined || bookmarkUpdate === null) {
        throw new Error("Missing the required parameter 'bookmarkUpdate' when calling updateBookmark");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Bookmark/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update bookmark.  Bookmarks are saved links that can be used to mark videos/frames of interest. They are scoped to a project and user, so if a user requests Bookmarks for a project they will only receive the Bookmarks created by them. 
     * @param {Number} id A unique integer identifying a bookmark.
     * @param {module:model/BookmarkUpdate} bookmarkUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateBookmark(id, bookmarkUpdate) {
      return this.updateBookmarkWithHttpInfo(id, bookmarkUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} id A unique integer identifying a bucket.
     * @param {module:model/BucketUpdate} bucketUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateBucketWithHttpInfo(id, bucketUpdate) {
      let postBody = bucketUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateBucket");
      }
      // verify the required parameter 'bucketUpdate' is set
      if (bucketUpdate === undefined || bucketUpdate === null) {
        throw new Error("Missing the required parameter 'bucketUpdate' when calling updateBucket");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Bucket/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update bucket.  Buckets allow users to specify a project-specific S3 bucket to store media. Buckets are defined at the Organization level. Creating and setting a bucket on a project requires administrative access within the organization. Once a bucket is defined for a project, all media subsequently uploaded to that project will be stored in the bucket. Projects may have media in multiple buckets. For example, if a project is initially created without setting a separate bucket and media is uploaded, then the bucket field is updated and more media is uploaded, that  project would then contain some media in the default bucket and some in the newly defined bucket. 
     * @param {Number} id A unique integer identifying a bucket.
     * @param {module:model/BucketUpdate} bucketUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateBucket(id, bucketUpdate) {
      return this.updateBucketWithHttpInfo(id, bucketUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} id A unique integer identifying a favorite.
     * @param {module:model/FavoriteUpdate} favoriteUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateFavoriteWithHttpInfo(id, favoriteUpdate) {
      let postBody = favoriteUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFavorite");
      }
      // verify the required parameter 'favoriteUpdate' is set
      if (favoriteUpdate === undefined || favoriteUpdate === null) {
        throw new Error("Missing the required parameter 'favoriteUpdate' when calling updateFavorite");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Favorite/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update favorite.  Favorites are saved annotation values to help speed up annotation. They are  scoped to a project and user, so if a user requests Favorites for a project they will only receive the Favorites created by them. 
     * @param {Number} id A unique integer identifying a favorite.
     * @param {module:model/FavoriteUpdate} favoriteUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateFavorite(id, favoriteUpdate) {
      return this.updateFavoriteWithHttpInfo(id, favoriteUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updated registered non-media File object
     * @param {Number} id A unique integer identifying a registered File object.
     * @param {module:model/FileUpdate} fileUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    updateFileWithHttpInfo(id, fileUpdate) {
      let postBody = fileUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFile");
      }
      // verify the required parameter 'fileUpdate' is set
      if (fileUpdate === undefined || fileUpdate === null) {
        throw new Error("Missing the required parameter 'fileUpdate' when calling updateFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/File/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updated registered non-media File object
     * @param {Number} id A unique integer identifying a registered File object.
     * @param {module:model/FileUpdate} fileUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    updateFile(id, fileUpdate) {
      return this.updateFileWithHttpInfo(id, fileUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes.   
     * @param {Number} id A unique integer identifying an file type.
     * @param {module:model/FileTypeUpdate} fileTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateFileTypeWithHttpInfo(id, fileTypeUpdate) {
      let postBody = fileTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateFileType");
      }
      // verify the required parameter 'fileTypeUpdate' is set
      if (fileTypeUpdate === undefined || fileTypeUpdate === null) {
        throw new Error("Missing the required parameter 'fileTypeUpdate' when calling updateFileType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/FileType/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update file type.  A file type is the metadata definition object for non-media FIle objects. It includes the name, description, and any associated user defined attributes.   
     * @param {Number} id A unique integer identifying an file type.
     * @param {module:model/FileTypeUpdate} fileTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateFileType(id, fileTypeUpdate) {
      return this.updateFileTypeWithHttpInfo(id, fileTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of images for the specified `role`.
     * @param {module:model/ImageDefinition} imageDefinition 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateImageFileWithHttpInfo(id, role, index, imageDefinition) {
      let postBody = imageDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateImageFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling updateImageFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling updateImageFile");
      }
      // verify the required parameter 'imageDefinition' is set
      if (imageDefinition === undefined || imageDefinition === null) {
        throw new Error("Missing the required parameter 'imageDefinition' when calling updateImageFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/ImageFile/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update image file.  Image files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying image. One or more image files can be used to reference thumbnails, thumbnail GIFs, or images in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the image file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of images for the specified `role`.
     * @param {module:model/ImageDefinition} imageDefinition 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateImageFile(id, role, index, imageDefinition) {
      return this.updateImageFileWithHttpInfo(id, role, index, imageDefinition)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} id A unique integer identifying a invitation.
     * @param {module:model/InvitationUpdate} invitationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateInvitationWithHttpInfo(id, invitationUpdate) {
      let postBody = invitationUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateInvitation");
      }
      // verify the required parameter 'invitationUpdate' is set
      if (invitationUpdate === undefined || invitationUpdate === null) {
        throw new Error("Missing the required parameter 'invitationUpdate' when calling updateInvitation");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Invitation/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update invitation.  Invitations allow users with administrative privileges for an organization to invite a user to join their organization using their email address. Upon creation, if automatic emails are configured an email will be sent to the specified email address. If the user has not yet registered, the email will contain a link to register using a registration token. If the user has registered, the email will send a link to accept the invitation. The link is also returned in the  response of the create method. 
     * @param {Number} id A unique integer identifying a invitation.
     * @param {module:model/InvitationUpdate} invitationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateInvitation(id, invitationUpdate) {
      return this.updateInvitationWithHttpInfo(id, invitationUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updated registered job cluster
     * @param {Number} id A unique integer identifying a registered job cluster.
     * @param {module:model/JobClusterSpec} jobClusterSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateJobClusterWithHttpInfo(id, jobClusterSpec) {
      let postBody = jobClusterSpec;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateJobCluster");
      }
      // verify the required parameter 'jobClusterSpec' is set
      if (jobClusterSpec === undefined || jobClusterSpec === null) {
        throw new Error("Missing the required parameter 'jobClusterSpec' when calling updateJobCluster");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/JobCluster/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updated registered job cluster
     * @param {Number} id A unique integer identifying a registered job cluster.
     * @param {module:model/JobClusterSpec} jobClusterSpec 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateJobCluster(id, jobClusterSpec) {
      return this.updateJobClusterWithHttpInfo(id, jobClusterSpec)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
     * @param {Number} id A unique integer identifying a leaf.
     * @param {module:model/LeafUpdate} leafUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateLeafWithHttpInfo(id, leafUpdate) {
      let postBody = leafUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateLeaf");
      }
      // verify the required parameter 'leafUpdate' is set
      if (leafUpdate === undefined || leafUpdate === null) {
        throw new Error("Missing the required parameter 'leafUpdate' when calling updateLeaf");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Leaf/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update leaf.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes. 
     * @param {Number} id A unique integer identifying a leaf.
     * @param {module:model/LeafUpdate} leafUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateLeaf(id, leafUpdate) {
      return this.updateLeafWithHttpInfo(id, leafUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk update on all leaves matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafBulkUpdate} leafBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateLeafListWithHttpInfo(project, leafBulkUpdate, opts) {
      opts = opts || {};
      let postBody = leafBulkUpdate;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling updateLeafList");
      }
      // verify the required parameter 'leafBulkUpdate' is set
      if (leafBulkUpdate === undefined || leafBulkUpdate === null) {
        throw new Error("Missing the required parameter 'leafBulkUpdate' when calling updateLeafList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'type': opts['type'],
        'name': opts['name'],
        'depth': opts['depth'],
        'leaf_id': this.apiClient.buildCollectionParam(opts['leafId'], 'multi'),
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Leaves/{project}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update leaf list.  Leaves are used to define label hierarchies that can be used for autocompletion of string attribute types. Leaves are a type of entity in Tator, meaning they can be described by user-defined attributes.   This method does a bulk update on all leaves matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LeafBulkUpdate} leafBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Number} opts.type Unique integer identifying a leaf type.
     * @param {String} opts.name Name of the leaf element.
     * @param {Number} opts.depth Get a specific tree depth. Root node depth is 0.
     * @param {Array.<Number>} opts.leafId Comma-separated list of leaf IDs.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateLeafList(project, leafBulkUpdate, opts) {
      return this.updateLeafListWithHttpInfo(project, leafBulkUpdate, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} id A unique integer identifying an leaf type.
     * @param {module:model/LeafTypeUpdate} leafTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateLeafTypeWithHttpInfo(id, leafTypeUpdate) {
      let postBody = leafTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateLeafType");
      }
      // verify the required parameter 'leafTypeUpdate' is set
      if (leafTypeUpdate === undefined || leafTypeUpdate === null) {
        throw new Error("Missing the required parameter 'leafTypeUpdate' when calling updateLeafType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/LeafType/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update leaf type.  A leaf type is the metadata definition object for a leaf. It includes name, description, and may have any number of user-defined attribute types associated with it. 
     * @param {Number} id A unique integer identifying an leaf type.
     * @param {module:model/LeafTypeUpdate} leafTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateLeafType(id, leafTypeUpdate) {
      return this.updateLeafTypeWithHttpInfo(id, leafTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a localization.
     * @param {module:model/LocalizationUpdate} localizationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateLocalizationWithHttpInfo(id, localizationUpdate) {
      let postBody = localizationUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateLocalization");
      }
      // verify the required parameter 'localizationUpdate' is set
      if (localizationUpdate === undefined || localizationUpdate === null) {
        throw new Error("Missing the required parameter 'localizationUpdate' when calling updateLocalization");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Localization/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update localization.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a localization.
     * @param {module:model/LocalizationUpdate} localizationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateLocalization(id, localizationUpdate) {
      return this.updateLocalizationWithHttpInfo(id, localizationUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all localizations matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationBulkUpdate} localizationBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateLocalizationListWithHttpInfo(project, localizationBulkUpdate, opts) {
      opts = opts || {};
      let postBody = localizationBulkUpdate;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling updateLocalizationList");
      }
      // verify the required parameter 'localizationBulkUpdate' is set
      if (localizationBulkUpdate === undefined || localizationBulkUpdate === null) {
        throw new Error("Missing the required parameter 'localizationBulkUpdate' when calling updateLocalizationList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs'],
        'excludeParents': opts['excludeParents'],
        'frame': opts['frame']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Localizations/{project}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update localiazation list.  Localizations are shape annotations drawn on a video or image. Available shapes (`dtype`) are  box, line, or dot. Each shape is parameterized by a different subset of data members: - `box` uses `x`, `y`, `width`, `height`. - `line` uses `x`, `y`, `u`, `v`. - `dot` uses `x` and `y`. - `poly` uses `points`.  Geometry members may be left null when creating a localization, in which case the shapes may be  drawn later using the redraw capability in the web UI. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all localizations matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/LocalizationBulkUpdate} localizationBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @param {Number} opts.excludeParents If a clone is present, do not send parent. This parameter will cause an exception if an Elasticsearch query is triggered and pagination parameters (start or stop) are included. (default to 0)
     * @param {Number} opts.frame Frame number of this localization if it is in a video.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateLocalizationList(project, localizationBulkUpdate, opts) {
      return this.updateLocalizationListWithHttpInfo(project, localizationBulkUpdate, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a localization type.
     * @param {module:model/LocalizationTypeUpdate} localizationTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateLocalizationTypeWithHttpInfo(id, localizationTypeUpdate) {
      let postBody = localizationTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateLocalizationType");
      }
      // verify the required parameter 'localizationTypeUpdate' is set
      if (localizationTypeUpdate === undefined || localizationTypeUpdate === null) {
        throw new Error("Missing the required parameter 'localizationTypeUpdate' when calling updateLocalizationType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/LocalizationType/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a localization type.
     * @param {module:model/LocalizationTypeUpdate} localizationTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateLocalizationType(id, localizationTypeUpdate) {
      return this.updateLocalizationTypeWithHttpInfo(id, localizationTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} id A unique integer identifying a media.
     * @param {module:model/MediaUpdate} mediaUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateMediaWithHttpInfo(id, mediaUpdate) {
      let postBody = mediaUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateMedia");
      }
      // verify the required parameter 'mediaUpdate' is set
      if (mediaUpdate === undefined || mediaUpdate === null) {
        throw new Error("Missing the required parameter 'mediaUpdate' when calling updateMedia");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Media/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   
     * @param {Number} id A unique integer identifying a media.
     * @param {module:model/MediaUpdate} mediaUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateMedia(id, mediaUpdate) {
      return this.updateMediaWithHttpInfo(id, mediaUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all media matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaBulkUpdate} mediaBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateMediaListWithHttpInfo(project, mediaBulkUpdate, opts) {
      opts = opts || {};
      let postBody = mediaBulkUpdate;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling updateMediaList");
      }
      // verify the required parameter 'mediaBulkUpdate' is set
      if (mediaBulkUpdate === undefined || mediaBulkUpdate === null) {
        throw new Error("Missing the required parameter 'mediaBulkUpdate' when calling updateMediaList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'type': opts['type'],
        'name': opts['name'],
        'section': opts['section'],
        'dtype': opts['dtype'],
        'md5': opts['md5'],
        'gid': opts['gid'],
        'uid': opts['uid'],
        'after': opts['after'],
        'after_id': opts['afterId'],
        'archive_lifecycle': opts['archiveLifecycle'],
        'annotation_search': opts['annotationSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Medias/{project}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update media list.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all media matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/MediaBulkUpdate} mediaBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId List of integers identifying media.
     * @param {Number} opts.type Unique integer identifying media type.
     * @param {String} opts.name Name of the media to filter on.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {module:model/String} opts.dtype Data type of the files, either image or video.
     * @param {String} opts.md5 MD5 sum of the media file.
     * @param {String} opts.gid Upload group ID of the media file.
     * @param {String} opts.uid Upload unique ID of the media file.
     * @param {String} opts.after DEPRECATED. `after_id` should be used instead to ensure correct results with duplicated filenames. If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
     * @param {Number} opts.afterId If given, all results returned will be after the media with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {module:model/String} opts.archiveLifecycle Archive lifecycle of the files, one of live (live only), archived (to_archive, archived, or to_live), or all. Defaults to 'live'
     * @param {String} opts.annotationSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to child annotations of media only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateMediaList(project, mediaBulkUpdate, opts) {
      return this.updateMediaListWithHttpInfo(project, mediaBulkUpdate, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying an media type.
     * @param {module:model/MediaTypeUpdate} mediaTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateMediaTypeWithHttpInfo(id, mediaTypeUpdate) {
      let postBody = mediaTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateMediaType");
      }
      // verify the required parameter 'mediaTypeUpdate' is set
      if (mediaTypeUpdate === undefined || mediaTypeUpdate === null) {
        throw new Error("Missing the required parameter 'mediaTypeUpdate' when calling updateMediaType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/MediaType/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update media type.  A media type is the metadata definition object for media. It includes file format, name, description, and may have any number of user defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying an media type.
     * @param {module:model/MediaTypeUpdate} mediaTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateMediaType(id, mediaTypeUpdate) {
      return this.updateMediaTypeWithHttpInfo(id, mediaTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} id A unique integer identifying a membership.
     * @param {module:model/MembershipUpdate} membershipUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateMembershipWithHttpInfo(id, membershipUpdate) {
      let postBody = membershipUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateMembership");
      }
      // verify the required parameter 'membershipUpdate' is set
      if (membershipUpdate === undefined || membershipUpdate === null) {
        throw new Error("Missing the required parameter 'membershipUpdate' when calling updateMembership");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Membership/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels: - `View Only` can only view a project and not change any data. - `Can Edit` can create, modify, and delete annotations. - `Can Transfer` can upload and download media. - `Can Execute` can launch algorithm workflows. - `Full Control` can change project settings, including inviting new members, project name, and    project metadata schema. 
     * @param {Number} id A unique integer identifying a membership.
     * @param {module:model/MembershipUpdate} membershipUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateMembership(id, membershipUpdate) {
      return this.updateMembershipWithHttpInfo(id, membershipUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   
     * @param {Number} id A unique integer identifying an organization.
     * @param {module:model/OrganizationUpdate} organizationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateOrganizationWithHttpInfo(id, organizationUpdate) {
      let postBody = organizationUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateOrganization");
      }
      // verify the required parameter 'organizationUpdate' is set
      if (organizationUpdate === undefined || organizationUpdate === null) {
        throw new Error("Missing the required parameter 'organizationUpdate' when calling updateOrganization");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Organization/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update organization.  Organizations are used to represent groups of users. Multiple projects may be owned by an organization, and users may be members of multiple organizations.   
     * @param {Number} id A unique integer identifying an organization.
     * @param {module:model/OrganizationUpdate} organizationUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateOrganization(id, organizationUpdate) {
      return this.updateOrganizationWithHttpInfo(id, organizationUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
     * @param {Number} id A unique integer identifying a project.
     * @param {module:model/ProjectUpdate} projectUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateProjectWithHttpInfo(id, projectUpdate) {
      let postBody = projectUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateProject");
      }
      // verify the required parameter 'projectUpdate' is set
      if (projectUpdate === undefined || projectUpdate === null) {
        throw new Error("Missing the required parameter 'projectUpdate' when calling updateProject");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Project/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.   
     * @param {Number} id A unique integer identifying a project.
     * @param {module:model/ProjectUpdate} projectUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateProject(id, projectUpdate) {
      return this.updateProjectWithHttpInfo(id, projectUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media. 
     * @param {Number} id A unique integer identifying a section.
     * @param {module:model/SectionUpdate} sectionUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    updateSectionWithHttpInfo(id, sectionUpdate) {
      let postBody = sectionUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateSection");
      }
      // verify the required parameter 'sectionUpdate' is set
      if (sectionUpdate === undefined || sectionUpdate === null) {
        throw new Error("Missing the required parameter 'sectionUpdate' when calling updateSection");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/rest/Section/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update section.  Sections represent groups of media using saved queries. The queries can be in the form of a [lucene search string](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax) or a list of [boolean filter queries](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) applied to either media or child annotations of media. 
     * @param {Number} id A unique integer identifying a section.
     * @param {module:model/SectionUpdate} sectionUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    updateSection(id, sectionUpdate) {
      return this.updateSectionWithHttpInfo(id, sectionUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a state.
     * @param {module:model/StateUpdate} stateUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateStateWithHttpInfo(id, stateUpdate) {
      let postBody = stateUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateState");
      }
      // verify the required parameter 'stateUpdate' is set
      if (stateUpdate === undefined || stateUpdate === null) {
        throw new Error("Missing the required parameter 'stateUpdate' when calling updateState");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/State/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes. 
     * @param {Number} id A unique integer identifying a state.
     * @param {module:model/StateUpdate} stateUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateState(id, stateUpdate) {
      return this.updateStateWithHttpInfo(id, stateUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all states matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateBulkUpdate} stateBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateStateListWithHttpInfo(project, stateBulkUpdate, opts) {
      opts = opts || {};
      let postBody = stateBulkUpdate;
      // verify the required parameter 'project' is set
      if (project === undefined || project === null) {
        throw new Error("Missing the required parameter 'project' when calling updateStateList");
      }
      // verify the required parameter 'stateBulkUpdate' is set
      if (stateBulkUpdate === undefined || stateBulkUpdate === null) {
        throw new Error("Missing the required parameter 'stateBulkUpdate' when calling updateStateList");
      }

      let pathParams = {
        'project': project
      };
      let queryParams = {
        'media_id': this.apiClient.buildCollectionParam(opts['mediaId'], 'csv'),
        'section': opts['section'],
        'type': opts['type'],
        'version': this.apiClient.buildCollectionParam(opts['version'], 'csv'),
        'after': opts['after'],
        'media_search': opts['mediaSearch'],
        'search': opts['search'],
        'attribute': this.apiClient.buildCollectionParam(opts['attribute'], 'csv'),
        'attribute_lt': this.apiClient.buildCollectionParam(opts['attributeLt'], 'csv'),
        'attribute_lte': this.apiClient.buildCollectionParam(opts['attributeLte'], 'csv'),
        'attribute_gt': this.apiClient.buildCollectionParam(opts['attributeGt'], 'csv'),
        'attribute_gte': this.apiClient.buildCollectionParam(opts['attributeGte'], 'csv'),
        'attribute_contains': this.apiClient.buildCollectionParam(opts['attributeContains'], 'csv'),
        'attribute_distance': this.apiClient.buildCollectionParam(opts['attributeDistance'], 'csv'),
        'attribute_null': this.apiClient.buildCollectionParam(opts['attributeNull'], 'csv'),
        'start': opts['start'],
        'stop': opts['stop'],
        'force_es': opts['forceEs']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/States/{project}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update state list.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.   This method does a bulk update on all states matching a query. Only  user-defined attributes may be bulk updated. 
     * @param {Number} project A unique integer identifying a project.
     * @param {module:model/StateBulkUpdate} stateBulkUpdate 
     * @param {Object} opts Optional parameters
     * @param {Array.<Number>} opts.mediaId Comma-separated list of media IDs.
     * @param {Number} opts.section Unique integer identifying a media section.
     * @param {Number} opts.type Unique integer identifying a annotation type.
     * @param {Array.<Number>} opts.version List of integers representing versions to fetch
     * @param {Number} opts.after If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
     * @param {String} opts.mediaSearch Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search is applied to parent media of annotations only.
     * @param {String} opts.search Lucene query syntax string for use with Elasticsearch. See [reference](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl-query-string-query.html#query-string-syntax). This search string only applies to the relevant objects, not children or parents. For media, child annotations can be searched with `annotation_search`. For localizations and states, parent media can be searched with `media_search`.
     * @param {Array.<String>} opts.attribute Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLt Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeLte Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGt Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeGte Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeContains Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
     * @param {Array.<String>} opts.attributeDistance Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
     * @param {Array.<String>} opts.attributeNull Attribute null filter. Returns elements for which a given attribute is not defined.
     * @param {Number} opts.start Pagination start index. Index of the first item in a larger list to return.
     * @param {Number} opts.stop Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
     * @param {module:model/Number} opts.forceEs Set to 1 to require an Elasticsearch based query. This can be used as a consistency check or for performance comparison.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateStateList(project, stateBulkUpdate, opts) {
      return this.updateStateListWithHttpInfo(project, stateBulkUpdate, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a state type.
     * @param {module:model/StateTypeUpdate} stateTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateStateTypeWithHttpInfo(id, stateTypeUpdate) {
      let postBody = stateTypeUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateStateType");
      }
      // verify the required parameter 'stateTypeUpdate' is set
      if (stateTypeUpdate === undefined || stateTypeUpdate === null) {
        throw new Error("Missing the required parameter 'stateTypeUpdate' when calling updateStateType");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/StateType/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and may have any number of user-defined attribute types associated with it.   
     * @param {Number} id A unique integer identifying a state type.
     * @param {module:model/StateTypeUpdate} stateTypeUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateStateType(id, stateTypeUpdate) {
      return this.updateStateTypeWithHttpInfo(id, stateTypeUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.   
     * @param {Number} id A unique integer identifying a version.
     * @param {module:model/VersionUpdate} versionUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateVersionWithHttpInfo(id, versionUpdate) {
      let postBody = versionUpdate;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateVersion");
      }
      // verify the required parameter 'versionUpdate' is set
      if (versionUpdate === undefined || versionUpdate === null) {
        throw new Error("Missing the required parameter 'versionUpdate' when calling updateVersion");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/Version/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.   
     * @param {Number} id A unique integer identifying a version.
     * @param {module:model/VersionUpdate} versionUpdate 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateVersion(id, versionUpdate) {
      return this.updateVersionWithHttpInfo(id, versionUpdate)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of videos for the specified `role`.
     * @param {module:model/VideoDefinition} videoDefinition 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/MessageResponse} and HTTP response
     */
    updateVideoFileWithHttpInfo(id, role, index, videoDefinition) {
      let postBody = videoDefinition;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling updateVideoFile");
      }
      // verify the required parameter 'role' is set
      if (role === undefined || role === null) {
        throw new Error("Missing the required parameter 'role' when calling updateVideoFile");
      }
      // verify the required parameter 'index' is set
      if (index === undefined || index === null) {
        throw new Error("Missing the required parameter 'index' when calling updateVideoFile");
      }
      // verify the required parameter 'videoDefinition' is set
      if (videoDefinition === undefined || videoDefinition === null) {
        throw new Error("Missing the required parameter 'videoDefinition' when calling updateVideoFile");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'role': role,
        'index': index
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = MessageResponse;
      return this.apiClient.callApi(
        '/rest/VideoFile/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update video file.  Video files are stored under the `media_files` field of `Media` objects. They are used to  relate media metadata to an underlying video. One or more video files can be used to reference streaming or archival roles in a `Media` object. The file itself must first be  uploaded to a URL retrieved from the `UploadInfo` endpoint, and the returned object key  should be specified in the video file's `path` field. 
     * @param {Number} id A unique integer identifying a media object.
     * @param {module:model/String} role Role of media file being referenced.
     * @param {Number} index Index of object. Must be less than size of current list of videos for the specified `role`.
     * @param {module:model/VideoDefinition} videoDefinition 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MessageResponse}
     */
    updateVideoFile(id, role, index, videoDefinition) {
      return this.updateVideoFileWithHttpInfo(id, role, index, videoDefinition)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Returns whether a user exists.
     * @param {Object} opts Optional parameters
     * @param {String} opts.username Username associated with user. Either this or email must be supplied.
     * @param {String} opts.email Email address associated with user. Either this or email must be supplied.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link Boolean} and HTTP response
     */
    userExistsWithHttpInfo(opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'username': opts['username'],
        'email': opts['email']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Boolean';
      return this.apiClient.callApi(
        '/rest/User/Exists', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Returns whether a user exists.
     * @param {Object} opts Optional parameters
     * @param {String} opts.username Username associated with user. Either this or email must be supplied.
     * @param {String} opts.email Email address associated with user. Either this or email must be supplied.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link Boolean}
     */
    userExists(opts) {
      return this.userExistsWithHttpInfo(opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get current user.  Retrieves user making the request. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/User} and HTTP response
     */
    whoamiWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['CookieAuth', 'TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = User;
      return this.apiClient.callApi(
        '/rest/User/GetCurrent', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get current user.  Retrieves user making the request. 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/User}
     */
    whoami() {
      return this.whoamiWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
